<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Fundamentals - Detailed 7-Mark Q&A</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #fdfaf6; color: #333; line-height: 1.7; }
        .container { max-width: 900px; margin-left: auto; margin-right: auto; padding: 1rem 2rem 2rem 2rem; }
        header h1 { color: #1e3a8a; font-size: 2.25rem; font-weight: 700; margin-bottom: 0.5rem; text-align: center; }
        header p.subtitle {text-align: center; color: #4b5563; margin-bottom: 2rem; font-size:0.9rem;}
        h2 { color: #1d4ed8; font-size: 1.75rem; font-weight:600; margin-top: 2.5rem; margin-bottom:1.5rem; border-bottom: 2px solid #3b82f6; padding-bottom: 0.5rem;}
        
        details.qa-block {
            background-color: white; 
            border-radius: 0.5rem; 
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06); 
            margin-bottom: 1.5rem; 
            border-left: 5px solid #1e3a8a; /* Darker blue for 7-mark */
            overflow: hidden; 
        }
        details.qa-block summary {
            padding: 1.25rem 1.5rem;
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: 600;
            color: #172554; /* Darker blue for 7-mark questions */
            list-style: none; 
            position: relative;
            outline: none;
        }
        details.qa-block summary::-webkit-details-marker { display: none; } 
        details.qa-block summary::before { 
            content: '▼';
            position: absolute;
            left: 0.5rem;
            top: 50%;
            transform: translateY(-50%) rotate(0deg);
            font-size: 0.8em;
            color: #1e3a8a;
            transition: transform 0.2s ease-in-out;
        }
        details.qa-block[open] summary::before {
            transform: translateY(-50%) rotate(180deg);
        }
        .answer-container {
            padding: 0 1.5rem 1.5rem 1.5rem; 
        }
        .citation-info { font-size: 0.8rem; color: #6b7280; display: block; margin-top: 0.25rem; margin-bottom: 1rem; font-style: italic;}
        .answer-section p, .answer-section ul, .answer-section ol { margin-bottom: 1rem; font-size:0.95rem; }
        .answer-section ul { list-style-type: disc; margin-left: 1.75rem; }
        .answer-section ol { list-style-type: decimal; margin-left: 1.75rem; }
        .answer-section strong { color: #172554; font-weight: 600;}
        .answer-section table { width: auto; min-width: 70%; margin-top:0.75rem; margin-bottom: 1rem; border-collapse: collapse; font-size: 0.9rem; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .answer-section th, .answer-section td { border: 1px solid #d1d5db; padding: 0.6rem 0.85rem; text-align: center; vertical-align: middle; }
        .answer-section th { background-color: #dbeafe; font-weight: 600; color: #1e3a8a;} 
        .answer-section td:first-child {text-align: left;} 
        .answer-section .code-block { background-color: #f8fafc; border: 1px solid #e2e8f0; padding: 1rem; border-radius: 0.375rem; font-family: 'Courier New', Courier, monospace; white-space: pre-wrap; margin-bottom: 1rem; font-size: 0.9rem; overflow-x: auto; line-height: 1.5;}
        .answer-section .diagram-description { background-color: #e0e7ff; border: 1px dashed #a5b4fc; border-left: 4px solid #4338ca; padding: 1rem; margin-top: 0.75rem; margin-bottom: 1rem; font-style: italic; color: #3730a3; border-radius: 0.25rem;}
        .answer-section img { max-width: 100%; height: auto; margin-top: 0.5rem; margin-bottom: 0.5rem; border: 1px solid #e5e7eb; border-radius: 0.25rem; display: block; margin-left:auto; margin-right:auto; }
        .back-link-container { margin-bottom: 2rem; text-align: center;}
        .back-link { display: inline-block; padding: 0.6rem 1.2rem; background-color: #3b82f6; color: white; border-radius: 0.375rem; text-decoration: none; transition: background-color 0.3s ease; font-weight: 500;}
        .back-link:hover { background-color: #2563eb; }
        hr.section-divider { border: none; height: 1px; background-color: #d1d5db; margin: 2rem 0; }
    </style>
</head>
<body class="antialiased">
    <div class="container">
        <header>
            <h1>Digital Fundamentals - Detailed Q&A</h1>
            <p class="subtitle">Comprehensive Answers for 7-Mark Question Themes</p>
            <div class="back-link-container">
                <a href="DF.html" class="back-link">&larr; Back to Main Analyzer Page</a>
                </div>
        </header>
        
        <section id="7markAnswersContainer">
            <h2>7-Mark Question Themes</h2>
            <p class="text-center text-gray-600 mb-8 text-sm">Detailed explanations for frequently encountered 7-mark question themes. Illustrative frequencies and example paper mentions (S=Summer, W=Winter) are based on analysis of the provided syllabus and past papers.</p>

            <details class="qa-block">
                <summary>1. Design a Synchronous counter for a given binary sequence (e.g., 0-1-3-7-6-4-0 or BCD) using T-flip-flops / JK-flip-flops.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~4, Example Papers: S2024 (OR), W2023 (OR), S2021, W2019)</p>
                    <div class="answer-section">
                        <p><strong>Concept:</strong> A synchronous counter is a sequential circuit where all flip-flops are triggered by the same clock pulse simultaneously. Designing such a counter involves several steps: determining the number of flip-flops required, creating a state transition table based on the desired sequence, deriving the excitation inputs for the chosen type of flip-flop (e.g., T or JK) using K-maps, and finally drawing the logic circuit diagram.</p>
                        <p><strong>Example Design: Design a synchronous counter for the sequence 0 → 1 → 3 → 7 → 6 → 4 → 0 ... using JK flip-flops.</strong></p>
                        <p><strong>Step 1: Determine the number of flip-flops.</strong><br/>The highest state in the sequence is 7, which is (111)<sub>2</sub> in binary. This requires 3 bits to represent all states in the sequence. Therefore, we need 3 flip-flops. Let's label their outputs as Q<sub>C</sub>, Q<sub>B</sub>, and Q<sub>A</sub>, where Q<sub>C</sub> is the Most Significant Bit (MSB).</p>
                        <p><strong>Step 2: Create the State Transition Table.</strong><br/>This table shows the present state of the counter, the desired next state according to the sequence, and the required J and K inputs for each flip-flop to achieve that transition. Unused states (in this case, 2 (010) and 5 (101)) are treated as "don't cares" (X), which can be used to simplify the logic.</p>
                        <table>
                            <thead>
                                <tr><th rowspan="2">Present State<br/>(Q<sub>C</sub>Q<sub>B</sub>Q<sub>A</sub>)</th><th rowspan="2">Decimal Equiv.</th><th rowspan="2">Next State<br/>(Q<sub>C(next)</sub>Q<sub>B(next)</sub>Q<sub>A(next)</sub>)</th><th rowspan="2">Decimal Equiv.</th><th colspan="2">FF<sub>C</sub> Inputs</th><th colspan="2">FF<sub>B</sub> Inputs</th><th colspan="2">FF<sub>A</sub> Inputs</th></tr>
                                <tr><th>J<sub>C</sub></th><th>K<sub>C</sub></th><th>J<sub>B</sub></th><th>K<sub>B</sub></th><th>J<sub>A</sub></th><th>K<sub>A</sub></th></tr>
                            </thead>
                            <tbody>
                                <tr><td>000</td><td>0</td><td>001</td><td>1</td><td>0</td><td>X</td><td>0</td><td>X</td><td>1</td><td>X</td></tr>
                                <tr><td>001</td><td>1</td><td>011</td><td>3</td><td>0</td><td>X</td><td>1</td><td>X</td><td>X</td><td>0</td></tr>
                                <tr><td>010</td><td>2</td><td>XXX</td><td>-</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr>
                                <tr><td>011</td><td>3</td><td>111</td><td>7</td><td>1</td><td>X</td><td>X</td><td>0</td><td>X</td><td>0</td></tr>
                                <tr><td>100</td><td>4</td><td>000</td><td>0</td><td>X</td><td>1</td><td>0</td><td>X</td><td>0</td><td>X</td></tr>
                                <tr><td>101</td><td>5</td><td>XXX</td><td>-</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr>
                                <tr><td>110</td><td>6</td><td>100</td><td>4</td><td>X</td><td>0</td><td>X</td><td>1</td><td>0</td><td>X</td></tr>
                                <tr><td>111</td><td>7</td><td>110</td><td>6</td><td>X</td><td>0</td><td>X</td><td>0</td><td>X</td><td>1</td></tr>
                            </tbody>
                        </table>
                        <p><em>Note: JK inputs are derived using the JK flip-flop excitation table: (Q→Q<sub>next</sub>: 0→0 ⇒ J=0,K=X; 0→1 ⇒ J=1,K=X; 1→0 ⇒ J=X,K=1; 1→1 ⇒ J=X,K=0).</em></p>
                        
                        <p><strong>Step 3: Use K-maps to derive simplified expressions for J<sub>C</sub>, K<sub>C</sub>, J<sub>B</sub>, K<sub>B</sub>, J<sub>A</sub>, K<sub>A</sub>.</strong></p>
                        <div class="diagram-description">
                            <p>Separate K-maps are drawn for each J and K input (6 K-maps in total). The inputs to these K-maps are Q<sub>C</sub>, Q<sub>B</sub>, and Q<sub>A</sub>. Don't care conditions for states 2 and 5 are used for simplification.</p>
                            <p><strong>For J<sub>A</sub>:</strong> Σm(0) + d(2,5). Grouping m0 yields <strong>J<sub>A</sub> = Q<sub>C</sub>'Q<sub>B</sub>'</strong></p>
                            <img src="https://placehold.co/300x200/e2e8f0/4a5568?text=K-Map+for+JA" alt="K-Map for JA">
                            <p><strong>For K<sub>A</sub>:</strong> Σm(7) + d(2,5). Grouping m7 yields <strong>K<sub>A</sub> = Q<sub>C</sub>Q<sub>B</sub></strong></p>
                            <img src="https://placehold.co/300x200/e2e8f0/4a5568?text=K-Map+for+KA" alt="K-Map for KA">
                            <p><strong>For J<sub>B</sub>:</strong> Σm(1) + d(2,5). Grouping m1 yields <strong>J<sub>B</sub> = Q<sub>C</sub>'Q<sub>A</sub></strong></p>
                            <img src="https://placehold.co/300x200/e2e8f0/4a5568?text=K-Map+for+JB" alt="K-Map for JB">
                            <p><strong>For K<sub>B</sub>:</strong> Σm(6) + d(2,5). Grouping m6 yields <strong>K<sub>B</sub> = Q<sub>C</sub>Q<sub>A</sub>'</strong></p>
                            <img src="https://placehold.co/300x200/e2e8f0/4a5568?text=K-Map+for+KB" alt="K-Map for KB">
                            <p><strong>For J<sub>C</sub>:</strong> Σm(3) + d(2,5). Grouping m3 yields <strong>J<sub>C</sub> = Q<sub>B</sub>Q<sub>A</sub></strong></p>
                            <img src="https://placehold.co/300x200/e2e8f0/4a5568?text=K-Map+for+JC" alt="K-Map for JC">
                            <p><strong>For K<sub>C</sub>:</strong> Σm(4) + d(2,5). Grouping m4 yields <strong>K<sub>C</sub> = Q<sub>B</sub>'Q<sub>A</sub>'</strong></p>
                            <img src="https://placehold.co/300x200/e2e8f0/4a5568?text=K-Map+for+KC" alt="K-Map for KC">
                        </div>
                        <p>The simplified expressions are:
                            J<sub>A</sub> = Q<sub>C</sub>'Q<sub>B</sub>'; K<sub>A</sub> = Q<sub>C</sub>Q<sub>B</sub>;
                            J<sub>B</sub> = Q<sub>C</sub>'Q<sub>A</sub>;  K<sub>B</sub> = Q<sub>C</sub>Q<sub>A</sub>';
                            J<sub>C</sub> = Q<sub>B</sub>Q<sub>A</sub>;   K<sub>C</sub> = Q<sub>B</sub>'Q<sub>A</sub>'.
                        </p>
                        
                        <p><strong>Step 4: Draw the Logic Circuit Diagram.</strong></p>
                        <div class="diagram-description">
                            <p>The circuit consists of three JK flip-flops (FF<sub>A</sub>, FF<sub>B</sub>, FF<sub>C</sub>). All share a common clock. Their J and K inputs are connected according to the derived expressions using AND gates and NOT gates (for complemented terms).</p>
                            <img src="https://placehold.co/600x400/e2e8f0/4a5568?text=Synchronous+Counter+Logic+Diagram" alt="Logic Diagram of the Synchronous Counter">
                        </div>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>2. Design a Combinational circuit that converts Binary to BCD (or BCD to Excess-3, or Gray to Binary).</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~4, Example Papers: S2024, S2024 (OR), W2023, W2023 (OR), W2021)</p>
                    <div class="answer-section">
                        <p><strong>Concept:</strong> A code converter is a combinational circuit that translates an input code into a different output code. The design process involves creating a truth table that maps each input combination to its corresponding output combination, then deriving simplified Boolean expressions for each output bit using K-maps, and finally implementing these expressions using logic gates.</p>
                        <p><strong>Example: Design a 4-bit BCD to Excess-3 Code Converter.</strong></p>
                        <p>BCD (Binary Coded Decimal) inputs represent decimal digits 0-9 using 4 bits (B<sub>3</sub>B<sub>2</sub>B<sub>1</sub>B<sub>0</sub>). Binary combinations for 10-15 are invalid BCD inputs and can be treated as "don't cares" (X).</p>
                        <p>Excess-3 code for a decimal digit is obtained by adding 3 to its BCD representation. Outputs are E<sub>3</sub>E<sub>2</sub>E<sub>1</sub>E<sub>0</sub>.</p>
                        <p><strong>Step 1: Truth Table</strong></p>
                        <table>
                            <thead>
                                <tr><th>Decimal</th><th>BCD Input (B<sub>3</sub>B<sub>2</sub>B<sub>1</sub>B<sub>0</sub>)</th><th>Excess-3 Output (E<sub>3</sub>E<sub>2</sub>E<sub>1</sub>E<sub>0</sub>)</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>0</td><td>0000</td><td>0011</td></tr>
                                <tr><td>1</td><td>0001</td><td>0100</td></tr>
                                <tr><td>2</td><td>0010</td><td>0101</td></tr>
                                <tr><td>3</td><td>0011</td><td>0110</td></tr>
                                <tr><td>4</td><td>0100</td><td>0111</td></tr>
                                <tr><td>5</td><td>0101</td><td>1000</td></tr>
                                <tr><td>6</td><td>0110</td><td>1001</td></tr>
                                <tr><td>7</td><td>0111</td><td>1010</td></tr>
                                <tr><td>8</td><td>1000</td><td>1011</td></tr>
                                <tr><td>9</td><td>1001</td><td>1100</td></tr>
                                <tr><td>10-15</td><td>1010-1111</td><td>XXXX (Don't Care)</td></tr>
                            </tbody>
                        </table>
                        <p><strong>Step 2: K-Maps and Boolean Expressions for E<sub>3</sub>, E<sub>2</sub>, E<sub>1</sub>, E<sub>0</sub>.</strong></p>
                        <p>Inputs for K-maps are B<sub>3</sub>, B<sub>2</sub>, B<sub>1</sub>, B<sub>0</sub>. Don't cares for minterms 10-15.</p>
                        <div class="diagram-description">
                            <p><strong>K-Map for E<sub>3</sub>:</strong> Σm(5,6,7,8,9) + d(10,11,12,13,14,15). Simplified: <strong>E<sub>3</sub> = B<sub>3</sub> + B<sub>2</sub>B<sub>1</sub> + B<sub>2</sub>B<sub>0</sub></strong></p>
                            <img src="images/7_mark/Q2_E3.png" alt="K-Map for E3 (BCD to Excess-3)">
                            <p><strong>K-Map for E<sub>2</sub>:</strong> Σm(1,2,3,4,9) + d(10,11,12,13,14,15). Simplified: <strong>E<sub>2</sub> = B<sub>2</sub>'B<sub>1</sub> + B<sub>2</sub>'B<sub>0</sub> + B<sub>2</sub>B<sub>1</sub>'B<sub>0</sub>'</strong></p>
                             <img src="images/7_mark/Q2_E2.png" alt="K-Map for E2 (BCD to Excess-3)">
                            <p><strong>K-Map for E<sub>1</sub>:</strong> Σm(0,3,4,7,8) + d(10,11,12,13,14,15). Simplified: <strong>E<sub>1</sub> = B<sub>1</sub>'B<sub>0</sub>' + B<sub>1</sub>B<sub>0</sub> = (B<sub>1</sub> ⊕ B<sub>0</sub>)'</strong> (XNOR)</p>
                             <img src="images/7_mark/Q2_E1.png" alt="K-Map for E1 (BCD to Excess-3)">
                            <p><strong>K-Map for E<sub>0</sub>:</strong> Σm(0,2,4,6,8) + d(10,11,12,13,14,15). Simplified: <strong>E<sub>0</sub> = B<sub>0</sub>'</strong></p>
                             <img src="images/7_mark/Q2_E0.png" alt="K-Map for E0 (BCD to Excess-3)">
                        </div>
                        
                        <p><strong>Step 3: Draw the Logic Circuit Diagram.</strong></p>
                        <div class="diagram-description">
                            <p>Implement the derived Boolean expressions for E<sub>3</sub>, E<sub>2</sub>, E<sub>1</sub>, E<sub>0</sub> using AND, OR, NOT, and XNOR (or XOR and NOT) gates as needed.</p>
                            <img src="images/7_mark/Q2.jpg" alt="Logic Diagram of BCD to Excess-3 Converter">
                        </div>
                    </div>
                </div>
            </details>
            
            <details class="qa-block">
                <summary>3. Explain Successive Approximation type A/D converter with a neat block diagram and working principle.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~4, Example Papers: W2024 (OR), S2023 (OR), W2021, W2019)</p>
                    <div class="answer-section">
                        <p>The <strong>Successive Approximation Register (SAR) Analog-to-Digital Converter (ADC)</strong> is a widely used type of ADC that offers a good balance between conversion speed and resolution. It works by iteratively comparing the input analog voltage (V<sub>in</sub>) with fractions of a reference voltage (V<sub>ref</sub>), determining one bit of the digital output at a time, from the Most Significant Bit (MSB) to the Least Significant Bit (LSB).</p>
                        
                        <p><strong>Block Diagram Components:</strong></p>
                        <ul>
                            <li><strong>Sample and Hold (S/H) Circuit:</strong> At the start of conversion, this circuit samples the analog input voltage V<sub>in</sub> and holds its value constant throughout the conversion process to ensure accuracy.</li>
                            <li><strong>Comparator:</strong> A high-speed analog comparator that compares the held analog input V<sub>in</sub> (from the S/H circuit) with an analog voltage V<sub>DAC</sub> generated by an internal DAC. Its output is a digital signal indicating whether V<sub>in</sub> is greater or less than V<sub>DAC</sub>.</li>
                            <li><strong>Successive Approximation Register (SAR):</strong> An N-bit digital register that generates an N-bit digital approximation of V<sub>in</sub>. It controls the internal DAC and updates its own value based on the comparator's output.</li>
                            <li><strong>Digital-to-Analog Converter (DAC):</strong> An N-bit DAC that converts the digital output of the SAR into an analog voltage V<sub>DAC</sub>, which is then fed to one input of the comparator.</li>
                            <li><strong>Control Logic & Clock:</strong> Manages the entire conversion sequence, including starting the conversion, controlling the SAR, timing the steps with clock pulses, and signaling the end of conversion.</li>
                            <li><strong>Reference Voltage (V<sub>ref</sub>):</strong> A stable and precise reference voltage used by the internal DAC.</li>
                        </ul>
                        <div class="diagram-description">
                            <p><strong>Block Diagram:</strong></p>
                            <p>The diagram shows the analog input V<sub>in</sub> going to the S/H circuit. The output of the S/H circuit goes to one input of the Comparator. The other input of the Comparator comes from the output of the internal DAC (V<sub>DAC</sub>). The Comparator's output feeds into the Control Logic of the SAR. The SAR has an N-bit digital output (which is the final ADC output) and also provides its N-bit digital value as input to the internal DAC. A Clock signal drives the Control Logic and SAR. An End-of-Conversion (EOC) signal is an output from the Control Logic.</p>
                            <img src="images/7_mark/Q3.jpg" alt="Block diagram of a Successive Approximation ADC">
                        </div>

                        <p><strong>Working Principle (N-bit conversion):</strong></p>
                        <p>The conversion process typically takes N clock cycles, where N is the number of bits of the ADC.</p>
                        <ol>
                            <li><strong>Initialization (Start of Conversion - SOC):</strong> The SAR is reset, and the S/H circuit acquires the analog input voltage V<sub>in</sub> and holds it.</li>
                            <li><strong>Cycle 1 (MSB Determination):</strong> The SAR sets its MSB to 1 and all other bits to 0 (e.g., for an 8-bit ADC, the SAR output is initially 10000000). This digital value is fed to the internal DAC, which produces an analog voltage V<sub>DAC</sub> (typically V<sub>ref</sub>/2).</li>
                            <li>The Comparator compares V<sub>in</sub> with V<sub>DAC</sub>:
                                <ul>
                                    <li>If V<sub>in</sub> ≥ V<sub>DAC</sub>: The MSB is correct and is kept as 1.</li>
                                    <li>If V<sub>in</sub> < V<sub>DAC</sub>: The MSB guess was too high, so the MSB is reset to 0.</li>
                                </ul>
                            </li>
                            <li><strong>Cycle 2 (Next Bit Determination):</strong> The SAR keeps the MSB value determined in the previous step and sets the next most significant bit (MSB-1) to 1. The new digital value from the SAR is converted by the DAC to a new V<sub>DAC</sub>.</li>
                            <li>Again, the Comparator compares V<sub>in</sub> with this new V<sub>DAC</sub>:
                                <ul>
                                    <li>If V<sub>in</sub> ≥ V<sub>DAC</sub>: The current bit (MSB-1) is kept as 1.</li>
                                    <li>If V<sub>in</sub> < V<sub>DAC</sub>: The current bit (MSB-1) is reset to 0.</li>
                                </ul>
                            </li>
                            <li><strong>Subsequent Cycles:</strong> This process of setting a bit, comparing, and then keeping or resetting the bit is repeated for each bit in the SAR, moving sequentially from the MSB down to the LSB.</li>
                            <li><strong>End of Conversion (EOC):</strong> After N clock cycles (one cycle per bit), the N-bit digital word stored in the SAR represents the closest digital approximation to the analog input voltage V<sub>in</sub>. The Control Logic then issues an End-of-Conversion signal.</li>
                        </ol>
                        <p>This method is like a binary search, homing in on the digital value that best represents the analog input.</p>
                        <div class="diagram-description">
                             <p><strong>Timing/Waveform (Conceptual):</strong> A timing diagram would show V<sub>in</sub> (held constant by S/H), V<sub>DAC</sub> (staircasing towards V<sub>in</sub> in N steps, where each step is a trial voltage), and the digital output bits being determined one by one with each clock cycle.</p>
                            <img src="https://placehold.co/500x250/e2e8f0/4a5568?text=SAR+ADC+Timing/Waveform" alt="SAR ADC Timing/Waveform">
                        </div>
                    </div>
                </div>
            </details>
            
            <details class="qa-block">
                <summary>4. Implement given Boolean functions using a PLA (Programmable Logic Array) or PAL.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~4, Example Papers: S2024, W2023, W2021 (OR), W2019 (OR))</p>
                    <div class="answer-section">
                        <p><strong>Concept:</strong> Programmable Logic Devices (PLDs) like PLA (Programmable Logic Array) and PAL (Programmable Array Logic) are used to implement combinational logic circuits by providing a structured way to realize sum-of-products (SOP) expressions.</p>
                        <ul>
                            <li><strong>PLA (Programmable Logic Array):</strong> In a PLA, both the AND array (which forms the product terms) and the OR array (which sums the product terms to form the outputs) are programmable. This offers high flexibility, as any product term can be routed to any OR gate.</li>
                            <li><strong>PAL (Programmable Array Logic):</strong> In a PAL, only the AND array is programmable. The OR array has fixed connections, meaning each OR gate is connected to a specific set of AND gate outputs (product terms). This structure is less flexible than PLA but often simpler and faster.</li>
                        </ul>
                        <p><strong>General Steps for Implementation using PLA/PAL:</strong></p>
                        <ol>
                            <li><strong>Obtain Minimized Boolean Functions:</strong> The functions to be implemented should be in a minimized Sum of Products (SOP) form. K-maps or other simplification techniques are used for this.</li>
                            <li><strong>Identify Unique Product Terms:</strong> List all unique product terms required across all the output functions.</li>
                            <li><strong>Create a PLA/PAL Programming Table:</strong>
                                <ul>
                                    <li>For PLA: The table shows inputs, the product terms generated by the AND array, and which product terms are connected to which OR gates to form the final output functions.</li>
                                    <li>For PAL: The table shows inputs and the product terms generated by the AND array. The connections to the OR gates are fixed and must be considered when assigning product terms.</li>
                                </ul>
                            </li>
                            <li><strong>Draw the PLA/PAL Structure:</strong> Sketch the logic diagram showing input buffers (providing true and complement forms of inputs), the AND array, the OR array, and the outputs. Mark the programmed connections (typically with an 'X' or a dot at the intersections in the AND array, and also in the OR array for PLA).</li>
                        </ol>
                        <p><strong>Example: Implement the following Boolean functions using a PLA:</strong><br/>
                        F1(A,B,C) = A'B' + A'BC + AB'C'<br/>
                        F2(A,B,C) = A'BC + A'BC' + AB'
                        </p>
                        <p><strong>Step 1 & 2: Minimized SOP and Unique Product Terms.</strong></p>
                        <p>The functions are already in SOP form. Let's identify unique product terms:</p>
                        <ul>
                            <li>PT1 = A'B' (for F1)</li>
                            <li>PT2 = A'BC (for F1 and F2)</li>
                            <li>PT3 = AB'C' (for F1)</li>
                            <li>PT4 = A'BC' (for F2)</li>
                            <li>PT5 = AB' (for F2)</li>
                        </ul>
                        <p><strong>Step 3: PLA Programming Table.</strong></p>
                        <table>
                            <thead>
                                <tr><th>Product Term (PT)</th><th>Inputs to AND gate (A B C)</th><th>Generated Term</th><th>Connect to OR for F1?</th><th>Connect to OR for F2?</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>PT1</td><td>0 0 X</td><td>A'B'</td><td>Yes</td><td>No</td></tr>
                                <tr><td>PT2</td><td>0 1 1</td><td>A'BC</td><td>Yes</td><td>Yes</td></tr>
                                <tr><td>PT3</td><td>1 0 0</td><td>AB'C'</td><td>Yes</td><td>No</td></tr>
                                <tr><td>PT4</td><td>0 1 0</td><td>A'BC'</td><td>No</td><td>Yes</td></tr>
                                <tr><td>PT5</td><td>1 0 X</td><td>AB'</td><td>No</td><td>Yes</td></tr>
                            </tbody>
                        </table>
                        <p><em>(X indicates the input is not connected for that specific product term, or its value doesn't matter for that term).</em></p>
                        <p><strong>Step 4: Draw the PLA Structure.</strong></p>
                        <div class="diagram-description">
                            <p>The diagram would show:</p>
                            <ul>
                                <li>Input lines for A, A', B, B', C, C' (from input buffers).</li>
                                <li>An AND array with 5 AND gates (one for each PT). Each AND gate has programmable connections to the input lines to form PT1 through PT5. For example, the AND gate for PT1 (A'B') connects to A' and B'.</li>
                                <li>An OR array with 2 OR gates (one for F1, one for F2).
                                    <ul>
                                        <li>The OR gate for F1 has programmable connections to the outputs of AND gates that generate PT1, PT2, and PT3.</li>
                                        <li>The OR gate for F2 has programmable connections to the outputs of AND gates that generate PT2, PT4, and PT5.</li>
                                    </ul>
                                </li>
                                <li>Outputs F1 and F2.</li>
                            </ul>
                            <p>Programmable connections are typically shown with an 'X' or a dot at the intersection of lines in both the AND and OR arrays.</p>
                            <img src="https://placehold.co/500x350/e2e8f0/4a5568?text=PLA+Implementation+Diagram" alt="PLA Implementation Diagram">
                        </div>
                        <p><strong>If using a PAL:</strong> The OR array connections would be fixed. For example, F1 might be hardwired to sum the outputs of the first three AND gates, and F2 to the next two. The design would then involve programming the AND array to generate the required product terms such that they feed into the correct, pre-assigned OR gates.</p>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>5. Write a detailed note on race around condition in JK flip-flops and how it is overcome using a Master-Slave JK flip-flop. Draw necessary diagrams.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~4, Example Papers: S2024, W2023, S2022 (OR), W2020)</p>
                    <div class="answer-section">
                        <p><strong>Race-Around Condition in JK Flip-Flop:</strong></p>
                        <p>The race-around condition is an undesirable phenomenon that can occur in **level-triggered JK flip-flops** (as opposed to edge-triggered ones). It specifically happens when both J and K inputs are held HIGH (J=1, K=1), which is the toggle condition. In a level-triggered flip-flop, the output can change as long as the clock input is at its active level (e.g., HIGH).</p>
                        <p><strong>Why it occurs:</strong></p>
                        <ol>
                            <li>When J=1, K=1, and the clock pulse is at its active level (e.g., CLK = HIGH).</li>
                            <li>The flip-flop is supposed to toggle its output Q. For instance, if Q was 0, it changes to 1.</li>
                            <li>However, if the duration for which the clock signal remains active (t<sub>p_clock</sub>) is longer than the propagation delay of the flip-flop (t<sub>pd_ff</sub>), the new output Q (now 1) is fed back to the inputs of the internal logic *while the clock is still active*.</li>
                            <li>With J=1, K=1 still applied and the clock still active, the flip-flop sees the conditions to toggle again. So, Q changes from 1 back to 0.</li>
                            <li>This cycle of toggling (0→1→0→1...) can repeat multiple times within a single active clock pulse if t<sub>p_clock</sub> > t<sub>pd_ff</sub>. This leads to an unpredictable final state of the flip-flop when the clock finally becomes inactive. The output "races" between 0 and 1.</li>
                        </ol>
                        <p>This makes the output unreliable and is a significant problem in practical circuit design.</p>
                        
                        <p><strong>Overcoming Race-Around Condition: The Master-Slave JK Flip-Flop</strong></p>
                        <p>The most common and effective method to eliminate the race-around condition is to use a **Master-Slave JK Flip-Flop** configuration. This configuration essentially uses two cascaded flip-flop stages: a "Master" stage and a "Slave" stage, clocked by complementary clock signals.</p>
                        <p><strong>Structure:</strong></p>
                        <ul>
                            <li>It consists of two JK flip-flops (or SR latches configured as JK). The first is the **Master** and the second is the **Slave**.</li>
                            <li>The external J and K inputs are applied to the Master flip-flop.</li>
                            <li>The outputs of the Master flip-flop (Q<sub>M</sub> and Q'<sub>M</sub>) are fed as inputs to the J and K inputs of the Slave flip-flop (J<sub>S</sub> = Q<sub>M</sub>, K<sub>S</sub> = Q'<sub>M</sub>).</li>
                            <li>The primary clock signal (CLK) is applied directly to the Master flip-flop.</li>
                            <li>An inverted version of the clock signal (CLK') is applied to the Slave flip-flop.</li>
                            <li>The final outputs of the Master-Slave configuration (Q and Q') are taken from the Slave flip-flop.</li>
                        </ul>
                        <div class="diagram-description">
                            <p><strong>Block Diagram of Master-Slave JK Flip-Flop:</strong></p>
                            <p>The diagram shows two JK flip-flop blocks.
                            <ul>
                                <li>The first block (Master) has inputs J, K, and CLK. Its outputs are Q<sub>M</sub> and Q'<sub>M</sub>.</li>
                                <li>Q<sub>M</sub> connects to the J input of the second block (Slave).</li>
                                <li>Q'<sub>M</sub> connects to the K input of the Slave.</li>
                                <li>The CLK signal goes through a NOT gate to produce CLK', which is connected to the clock input of the Slave.</li>
                                <li>The final outputs Q and Q' are taken from the Slave flip-flop.</li>
                            </ul>
                            <img src="images/7_mark/Q5.jpg" alt="Master-Slave JK Flip-Flop Block Diagram">
                        </div>

                        <p><strong>Working Principle:</strong></p>
                        <ol>
                            <li><strong>When CLK is HIGH (or on its active edge, e.g., positive level/edge for the master):</strong>
                                <ul>
                                    <li>The Master flip-flop is enabled and responds to the external J and K inputs. It determines its next state based on J, K, and its current state.</li>
                                    <li>During this time, the Slave flip-flop is disabled because its clock input (CLK') is LOW. Therefore, the external outputs Q and Q' of the overall Master-Slave configuration do not change yet, even if the Master's internal state changes. This isolates the output from the input changes during the first phase of the clock.</li>
                                </ul>
                            </li>
                            <li><strong>When CLK goes LOW (or on its active edge, e.g., negative level/edge for the slave):</strong>
                                <ul>
                                    <li>The Master flip-flop is disabled; its inputs (J, K) no longer affect it, and its state (Q<sub>M</sub>, Q'<sub>M</sub>) is latched and held.</li>
                                    <li>Now, the Slave flip-flop is enabled (as CLK' is HIGH). It takes its inputs from the latched outputs of the master (J<sub>S</sub>=Q<sub>M</sub>, K<sub>S</sub>=Q'<sub>M</sub>) and updates its own state accordingly.</li>
                                    <li>The external outputs Q and Q' of the Master-Slave flip-flop now reflect the state that was captured by the master during the first phase of the clock pulse.</li>
                                </ul>
                            </li>
                        </ol>
                        <p>This two-phase operation ensures that the overall output Q changes only once per complete clock pulse (typically on the falling edge of the CLK if the master is positive edge/level triggered and the slave is triggered by the inverted clock). The master "catches" the state while the clock is active, and the slave "releases" or transfers this state to the output when the clock becomes inactive (or on the opposite edge). This effectively isolates the input and output stages during the critical toggling period, preventing the output from racing.</p>
                        <p>Modern JK flip-flops are usually edge-triggered rather than level-triggered. Edge-triggering itself (responding only to the very short transition of the clock edge) also inherently solves the race-around problem because the input conditions are sampled only for a very brief instant, not for the entire duration the clock is active.</p>
                        <div class="diagram-description">
                            <p><strong>Timing Diagram Illustrating Race-Around Avoidance:</strong></p>
                            <p>A timing diagram would show CLK, J, K, Q<sub>M</sub> (Master output), and Q (Slave output). It would illustrate how Q<sub>M</sub> might change based on J and K while CLK is high, but Q only changes when CLK goes low (and CLK' goes high), reflecting the stable state of Q<sub>M</sub>.</p>
                            <img src="images/7_mark/Q5_1.jpg" alt="Master-Slave JK Flip-Flop Timing Diagram">
                        </div>
                    </div>
                </div>
            </details>
            
            <details class="qa-block">
                <summary>6. Implement basic logic gates (AND, OR, NOT, EX-OR) using only NAND gates (or only NOR gates). Explain universality.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~3, Example Papers: S2024, W2023, W2019)</p>
                    <div class="answer-section">
                        <p><strong>Universality of Logic Gates:</strong></p>
                        <p>A logic gate is called a **universal gate** if any Boolean function can be implemented using only that type of gate, without needing any other type of gate. Equivalently, a gate is universal if the three fundamental logic operations—AND, OR, and NOT—can be constructed using only that gate. Since any digital circuit can be built using combinations of AND, OR, and NOT gates, a universal gate can, by extension, be used to build any digital circuit. The NAND gate and the NOR gate are well-known universal gates.</p>
                        
                        <hr class="section-divider"/>
                        <p><strong>NAND Gate as a Universal Gate:</strong></p>
                        <p>The NAND gate (NOT-AND) gives an output of 0 only if all its inputs are 1.</p>
                        <ol>
                            <li><strong>NOT Gate from NAND:</strong>
                                <p>To create a NOT gate (inverter) using a NAND gate, both inputs of the NAND gate are connected together to a single input A. Alternatively, one input can be tied to logic '1'.</p>
                                <p>If input A is applied to both inputs: Output = (A ⋅ A)' = A' (since A ⋅ A = A).</p>
                                <div class="diagram-description">
                                    <p>Diagram: A single 2-input NAND gate. Both inputs are connected together and labeled 'A'. The output is labeled 'A''.</p>
                                    <img src="images/7_mark/Q6_1.png" alt="NOT gate from NAND">
                                </div>
                            </li>
                            <li><strong>AND Gate from NAND:</strong>
                                <p>An AND operation (Y = A ⋅ B) can be achieved by inverting the output of a NAND gate. This is done by using a NAND gate followed by another NAND gate configured as a NOT gate (as described above).</p>
                                <p>Output = ((A ⋅ B)')' = A ⋅ B (by double negation).</p>
                                <div class="diagram-description">
                                    <p>Diagram: Inputs A and B go into a 2-input NAND gate. Its output goes into both inputs of a second 2-input NAND gate (which acts as an inverter). The final output is Y = A ⋅ B.</p>
                                    <img src="images/7_mark/Q6_2.webp" alt="AND gate from NAND">
                                </div>
                            </li>
                            <li><strong>OR Gate from NAND:</strong>
                                <p>An OR operation (Y = A + B) can be achieved by applying De Morgan's theorem: A + B = (A' ⋅ B')'. This means we first invert A, then invert B, and then NAND the inverted inputs.</p>
                                <p>Input A → NAND (as NOT) → A'</p>
                                <p>Input B → NAND (as NOT) → B'</p>
                                <p>Then, these A' and B' are inputs to a third NAND gate: Output = (A' ⋅ B')' = (A')' + (B')' = A + B.</p>
                                <div class="diagram-description">
                                    <p>Diagram: Input A goes to a NAND gate (inputs tied) producing A'. Input B goes to another NAND gate (inputs tied) producing B'. The outputs A' and B' go into a third 2-input NAND gate. The final output is Y = A + B. (Total 3 NAND gates).</p>
                                    <img src="images/7_mark/Q6_3.png" alt="OR gate from NAND">
                                </div>
                            </li>
                            <li><strong>EX-OR Gate from NAND:</strong>
                                <p>An EX-OR operation (Y = A ⊕ B = A'B + AB') can be implemented using four 2-input NAND gates.</p>
                                <div class="diagram-description">
                                    <p>Diagram: A common 4-NAND gate configuration for EX-OR:
                                    <ul>
                                        <li>NAND1: Inputs A, B; Output P1 = (AB)'</li>
                                        <li>NAND2: Inputs A, P1; Output P2 = (A ⋅ (AB)')' = A' + AB</li>
                                        <li>NAND3: Inputs B, P1; Output P3 = (B ⋅ (AB)')' = B' + AB</li>
                                        <li>NAND4: Inputs P2, P3; Output Y = (P2 ⋅ P3)' = A'B + AB' = A ⊕ B</li>
                                    </ul>
                                    </p>
                                    <img src="images/7_mark/Q6_4.webp" alt="EX-OR gate from NAND">
                                </div>
                            </li>
                        </ol>
                        
                        <hr class="section-divider"/>
                        <p><strong>NOR Gate as a Universal Gate:</strong></p>
                        <p>The NOR gate (NOT-OR) gives an output of 0 if any of its inputs are 1.</p>
                        <ol>
                            <li><strong>NOT Gate from NOR:</strong>
                                <p>Both inputs of a NOR gate are connected together to a single input A. Alternatively, one input can be tied to logic '0'.</p>
                                <p>Output = (A + A)' = A' (since A + A = A).</p>
                                <div class="diagram-description">
                                    <p>Diagram: A single 2-input NOR gate. Both inputs are connected together and labeled 'A'. The output is labeled 'A''.</p>
                                    <img src="images/7_mark/Q6_5.webp" alt="NOT gate from NOR">
                                </div>
                            </li>
                            <li><strong>OR Gate from NOR:</strong>
                                <p>An OR operation (Y = A + B) is achieved by inverting the output of a NOR gate.</p>
                                <p>Output = ((A + B)')' = A + B.</p>
                                <div class="diagram-description">
                                    <p>Diagram: Inputs A and B go into a 2-input NOR gate. Its output goes into both inputs of a second 2-input NOR gate (acting as an inverter). The final output is Y = A + B.</p>
                                    <img src="images/7_mark/Q6_6.webp" alt="OR gate from NOR">
                                </div>
                            </li>
                            <li><strong>AND Gate from NOR:</strong>
                                <p>Using De Morgan's theorem, A ⋅ B = (A' + B')'. This means we first invert A, then invert B, and then NOR the inverted inputs.</p>
                                <p>Input A → NOR (as NOT) → A'</p>
                                <p>Input B → NOR (as NOT) → B'</p>
                                <p>Then, these A' and B' are inputs to a third NOR gate: Output = (A' + B')' = (A')' ⋅ (B')' = A ⋅ B.</p>
                                <div class="diagram-description">
                                    <p>Diagram: Input A goes to a NOR gate (inputs tied) producing A'. Input B goes to another NOR gate (inputs tied) producing B'. The outputs A' and B' go into a third 2-input NOR gate. The final output is Y = A ⋅ B. (Total 3 NOR gates).</p>
                                    <img src="images/7_mark/Q6_7.webp" alt="AND gate from NOR">
                                </div>
                            </li>
                            <li><strong>EX-OR Gate from NOR:</strong>
                                <p>An EX-OR operation (Y = A ⊕ B) can be implemented using five 2-input NOR gates. (An EX-NOR can be made with 4 NOR gates, and then one more NOR as an inverter for EX-OR).</p>
                                <div class="diagram-description">
                                    <p>Diagram: A common 5-NOR gate configuration for EX-OR.</p>
                                    <img src="images/7_mark/Q6_8.webp" alt="EX-OR gate from NOR">
                                </div>
                            </li>
                        </ol>
                        <p>Since both NAND and NOR gates can be used to construct the fundamental AND, OR, and NOT operations, they are considered universal gates.</p>
                    </div>
                </div>
            </details>
            
            <details class="qa-block">
                <summary>7. Design a 2-Bit or 3-Bit Magnitude Comparator circuit. Show truth table, K-maps, and logic diagram.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~3, Example Papers: S2024, W2023, S2022)</p>
                    <div class="answer-section">
                        <p>A **Magnitude Comparator** is a combinational logic circuit that compares two binary numbers (A and B) and determines their relative magnitudes. It typically produces three outputs: one indicating if A > B (Greater), one if A = B (Equal), and one if A < B (Less).</p>
                        <p><strong>Design of a 2-Bit Magnitude Comparator:</strong></p>
                        <p>Let the two 2-bit binary numbers be A = A<sub>1</sub>A<sub>0</sub> and B = B<sub>1</sub>B<sub>0</sub>, where A<sub>1</sub> and B<sub>1</sub> are the Most Significant Bits (MSBs).</p>
                        <p>The outputs will be:</p>
                        <ul>
                            <li>G: (A > B) output</li>
                            <li>E: (A = B) output</li>
                            <li>L: (A < B) output</li>
                        </ul>
                        <p><strong>Step 1: Truth Table</strong></p>
                        <p>The truth table will have 2<sup>4</sup> = 16 rows for the four inputs A<sub>1</sub>, A<sub>0</sub>, B<sub>1</sub>, B<sub>0</sub>.</p>
                        <table>
                            <thead>
                                <tr><th>A<sub>1</sub></th><th>A<sub>0</sub></th><th>B<sub>1</sub></th><th>B<sub>0</sub></th><th>Decimal A</th><th>Decimal B</th><th>G (A>B)</th><th>E (A=B)</th><th>L (A<B)</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
                                <tr><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
                                <tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>2</td><td>0</td><td>0</td><td>1</td></tr>
                                <tr><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>3</td><td>0</td><td>0</td><td>1</td></tr>
                                <tr><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
                                <tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>
                                <tr><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>2</td><td>0</td><td>0</td><td>1</td></tr>
                                <tr><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>3</td><td>0</td><td>0</td><td>1</td></tr>
                                <tr><td>1</td><td>0</td><td>0</td><td>0</td><td>2</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
                                <tr><td>1</td><td>0</td><td>0</td><td>1</td><td>2</td><td>1</td><td>1</td><td>0</td><td>0</td></tr>
                                <tr><td>1</td><td>0</td><td>1</td><td>0</td><td>2</td><td>2</td><td>0</td><td>1</td><td>0</td></tr>
                                <tr><td>1</td><td>0</td><td>1</td><td>1</td><td>2</td><td>3</td><td>0</td><td>0</td><td>1</td></tr>
                                <tr><td>1</td><td>1</td><td>0</td><td>0</td><td>3</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
                                <tr><td>1</td><td>1</td><td>0</td><td>1</td><td>3</td><td>1</td><td>1</td><td>0</td><td>0</td></tr>
                                <tr><td>1</td><td>1</td><td>1</td><td>0</td><td>3</td><td>2</td><td>1</td><td>0</td><td>0</td></tr>
                                <tr><td>1</td><td>1</td><td>1</td><td>1</td><td>3</td><td>3</td><td>0</td><td>1</td><td>0</td></tr>
                            </tbody>
                        </table>

                        <p><strong>Step 2: K-Maps and Boolean Expressions</strong></p>
                        <p>We need to create 4-variable K-maps for G, E, and L using A<sub>1</sub>, A<sub>0</sub>, B<sub>1</sub>, B<sub>0</sub> as inputs.</p>
                        <div class="diagram-description">
                            <p><strong>K-Map for G (A > B):</strong> Plot 1s for minterms where A > B (m4, m8, m9, m12, m13, m14).</p>
                            <img src="images/7_mark/Q7_1.webp" alt="K-Map for G (A>B)">
                            <p>Simplified G = A<sub>1</sub>B<sub>1</sub>' + A<sub>0</sub>B<sub>1</sub>'B<sub>0</sub>' + A<sub>1</sub>A<sub>0</sub>B<sub>0</sub>'</p>

                            <p><strong>K-Map for E (A = B):</strong> Plot 1s for minterms where A = B (m0, m5, m10, m15).</p>
                            <img src="images/7_mark/Q7_2.webp" alt="K-Map for E (A=B)">
                            <p>Simplified E = A<sub>1</sub>'A<sub>0</sub>'B<sub>1</sub>'B<sub>0</sub>' + A<sub>1</sub>'A<sub>0</sub>B<sub>1</sub>'B<sub>0</sub> + A<sub>1</sub>A<sub>0</sub>'B<sub>1</sub>B<sub>0</sub>' + A<sub>1</sub>A<sub>0</sub>B<sub>1</sub>B<sub>0</sub><br/>
                            This can also be written as: E = (A<sub>1</sub>⊙B<sub>1</sub>) ⋅ (A<sub>0</sub>⊙B<sub>0</sub>) where ⊙ is XNOR.</p>

                            <p><strong>K-Map for L (A < B):</strong> Plot 1s for minterms where A < B (m1, m2, m3, m6, m7, m11).</p>
                            <img src="images/7_mark/Q7_3.webp" alt="K-Map for L (A<B)">
                            <p>Simplified L = A<sub>1</sub>'B<sub>1</sub> + A<sub>0</sub>'B<sub>1</sub>B<sub>0</sub> + A<sub>1</sub>'A<sub>0</sub>'B<sub>0</sub></p>
                        </div>
                        <p>Alternatively, logical expressions can be derived:
                        G = A<sub>1</sub>B<sub>1</sub>' + (A<sub>1</sub>⊙B<sub>1</sub>)A<sub>0</sub>B<sub>0</sub>'
                        E = (A<sub>1</sub>⊙B<sub>1</sub>) ⋅ (A<sub>0</sub>⊙B<sub>0</sub>)
                        L = A<sub>1</sub>'B<sub>1</sub> + (A<sub>1</sub>⊙B<sub>1</sub>)A<sub>0</sub>'B<sub>0</sub>
                        </p>

                        <p><strong>Step 3: Logic Diagram</strong></p>
                        <div class="diagram-description">
                            <p>The circuit would implement the simplified Boolean expressions for G, E, and L using AND, OR, NOT, and XNOR gates.</p>
                            <img src="images/7_mark/Q7.webp" alt="Logic Diagram of a 2-bit Magnitude Comparator">
                        </div>
                    </div>
                </div>
            </details>
            
            <details class="qa-block">
                <summary>8. Implement a given Boolean function (e.g., F(A,B,C,D) = Σm(...)) using an 8x1 MUX (or appropriate MUX).</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~3, Example Papers: S2024, W2023 (OR), S2022)</p>
                    <div class="answer-section">
                        <p>A Multiplexer (MUX) can be used as a universal logic element to implement Boolean functions. An 8:1 MUX has 8 data inputs (I<sub>0</sub> to I<sub>7</sub>), 3 select lines (S<sub>2</sub>, S<sub>1</sub>, S<sub>0</sub>), and 1 output (Y).</p>
                        <p>To implement an N-variable function using a MUX with M select lines, we typically use M variables of the function for the select lines. The remaining N-M variables are used to determine the connections to the MUX's data inputs (these connections can be 0, 1, one of the remaining variables, or its complement).</p>
                        <p><strong>Example: Implement F(A,B,C,D) = Σm(0, 1, 3, 4, 8, 9, 15) using an 8x1 MUX.</strong></p>
                        <p>Here, N=4 variables (A, B, C, D). An 8x1 MUX has M=3 select lines.</p>
                        <ol>
                            <li>
                                <p><strong>Assign Select Lines and Data Input Variable:</strong></p>
                                Let A, B, C be the select lines:
                                <ul>
                                    <li>S<sub>2</sub> = A (Most Significant Select line)</li>
                                    <li>S<sub>1</sub> = B</li>
                                    <li>S<sub>0</sub> = C (Least Significant Select line)</li>
                                </ul>
                                The remaining variable, D, will be used to determine the values for the data inputs I<sub>0</sub> through I<sub>7</sub>.
                            </li>
                            <li>
                                <p><strong>Create the MUX Implementation Table:</strong></p>
                                <p>The table lists all combinations of the select lines (A, B, C). For each combination, we examine the two minterms that could be selected based on the value of D (D=0 or D=1) and determine what I<sub>i</sub> should be connected to (0, 1, D, or D') to produce the correct function output.</p>
                                <table>
                                    <thead>
                                        <tr><th>A(S<sub>2</sub>)</th><th>B(S<sub>1</sub>)</th><th>C(S<sub>0</sub>)</th><th>MUX Data Input Line (I<sub>i</sub>)</th><th>Minterm (D=0)</th><th>Minterm (D=1)</th><th>F for D=0</th><th>F for D=1</th><th>Connect I<sub>i</sub> to:</th></tr>
                                    </thead>
                                    <tbody>
                                        <tr><td>0</td><td>0</td><td>0</td><td>I<sub>0</sub></td><td>m0 (A'B'C'D')</td><td>m1 (A'B'C'D)</td><td>1 (m0 is in F)</td><td>1 (m1 is in F)</td><td><strong>1</strong></td></tr>
                                        <tr><td>0</td><td>0</td><td>1</td><td>I<sub>1</sub></td><td>m2 (A'B'CD')</td><td>m3 (A'B'CD)</td><td>0 (m2 not in F)</td><td>1 (m3 is in F)</td><td><strong>D</strong></td></tr>
                                        <tr><td>0</td><td>1</td><td>0</td><td>I<sub>2</sub></td><td>m4 (A'BC'D')</td><td>m5 (A'BC'D)</td><td>1 (m4 is in F)</td><td>0 (m5 not in F)</td><td><strong>D'</strong></td></tr>
                                        <tr><td>0</td><td>1</td><td>1</td><td>I<sub>3</sub></td><td>m6 (A'BCD')</td><td>m7 (A'BCD)</td><td>0 (m6 not in F)</td><td>0 (m7 not in F)</td><td><strong>0</strong></td></tr>
                                        <tr><td>1</td><td>0</td><td>0</td><td>I<sub>4</sub></td><td>m8 (AB'C'D')</td><td>m9 (AB'C'D)</td><td>1 (m8 is in F)</td><td>1 (m9 is in F)</td><td><strong>1</strong></td></tr>
                                        <tr><td>1</td><td>0</td><td>1</td><td>I<sub>5</sub></td><td>m10 (AB'CD')</td><td>m11 (AB'CD)</td><td>0 (m10 not in F)</td><td>0 (m11 not in F)</td><td><strong>0</strong></td></tr>
                                        <tr><td>1</td><td>1</td><td>0</td><td>I<sub>6</sub></td><td>m12 (ABC'D')</td><td>m13 (ABC'D)</td><td>0 (m12 not in F)</td><td>0 (m13 not in F)</td><td><strong>0</strong></td></tr>
                                        <tr><td>1</td><td>1</td><td>1</td><td>I<sub>7</sub></td><td>m14 (ABCD')</td><td>m15 (ABCD)</td><td>0 (m14 not in F)</td><td>1 (m15 is in F)</td><td><strong>D</strong></td></tr>
                                    </tbody>
                                </table>
                            </li>
                            <li>
                                <p><strong>Draw the Logic Diagram:</strong></p>
                                <div class="diagram-description">
                                    <p>The diagram would show an 8x1 MUX block.</p>
                                    <ul>
                                        <li>Select lines S<sub>2</sub>, S<sub>1</sub>, S<sub>0</sub> are connected to A, B, C respectively.</li>
                                        <li>Data Inputs are connected as determined in the table:
                                            <ul>
                                                <li>I<sub>0</sub> is connected to Logic 1 (V<sub>cc</sub>).</li>
                                                <li>I<sub>1</sub> is connected to input variable D.</li>
                                                <li>I<sub>2</sub> is connected to D' (input D passed through a NOT gate).</li>
                                                <li>I<sub>3</sub> is connected to Logic 0 (Ground).</li>
                                                <li>I<sub>4</sub> is connected to Logic 1 (V<sub>cc</sub>).</li>
                                                <li>I<sub>5</sub> is connected to Logic 0 (Ground).</li>
                                                <li>I<sub>6</sub> is connected to Logic 0 (Ground).</li>
                                                <li>I<sub>7</sub> is connected to input variable D.</li>
                                            </ul>
                                        </li>
                                        <li>The single output Y of the MUX represents the function F(A,B,C,D).</li>
                                    </ul>
                                    <img src="https://placehold.co/450x350/e2e8f0/4a5568?text=8x1+MUX+Implementation+Diagram" alt="Logic Diagram of F(A,B,C,D) using 8x1 MUX">
                                </div>
                            </li>
                        </ol>
                    </div>
                </div>
            </details>
            
            <details class="qa-block">
                <summary>9. Explain the working of an R-2R Ladder D/A converter with a neat diagram and derive its output voltage equation.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~3, Example Papers: W2024, S2023, W2020)</p>
                    <div class="answer-section">
                        <p>The <strong>R-2R Ladder Digital-to-Analog Converter (DAC)</strong> is a widely used circuit for converting digital binary inputs into a proportional analog output voltage. Its primary advantage over other types like the binary-weighted resistor DAC is that it requires only two distinct resistor values (R and 2R). This makes it significantly easier to fabricate integrated circuits with high precision because it's easier to match ratios of resistors than to create a wide range of accurately valued resistors.</p>
                        
                        <p><strong>Structure:</strong></p>
                        <p>For an n-bit digital input word (B<sub>n-1</sub>, B<sub>n-2</sub>, ..., B<sub>0</sub>, where B<sub>n-1</sub> is the Most Significant Bit (MSB) and B<sub>0</sub> is the Least Significant Bit (LSB)), the R-2R ladder network is constructed as follows:</p>
                        <ul>
                            <li>The ladder consists of a series of resistors of value R forming the "horizontal rungs."</li>
                            <li>For each digital input bit B<sub>i</sub>, there's a resistor of value 2R connected vertically.</li>
                            <li>Each of these 2R resistors is connected via an electronic switch (controlled by the corresponding bit B<sub>i</sub>). If B<sub>i</sub>=1, the switch connects the 2R resistor to a stable reference voltage (V<sub>ref</sub>). If B<sub>i</sub>=0, the switch connects the 2R resistor to ground (0V).</li>
                            <li>The "bottom" of each switched 2R resistor connects to a node in the R-ladder (at the junction of two R resistors or at the output node).</li>
                            <li>Crucially, the LSB end of the R-ladder network is terminated with a 2R resistor connected to ground. This termination is essential for maintaining the characteristic impedance of the ladder.</li>
                        </ul>
                        <p>The analog output voltage (V<sub>out</sub>) is typically taken from the MSB end of the ladder. This output is often buffered by an operational amplifier (op-amp) configured as a voltage follower to provide a low-impedance output, or the entire ladder network can feed into the summing junction of an op-amp in an inverting amplifier configuration.</p>

                        <div class="diagram-description">
                            <p><strong>Conceptual Diagram (e.g., for a 3-bit R-2R DAC):</strong></p>
                            <p>Imagine inputs B<sub>2</sub> (MSB), B<sub>1</sub>, B<sub>0</sub> (LSB).</p>
                            <ul>
                                <li>At the B<sub>2</sub> input, a switch connects a 2R resistor to either V<sub>ref</sub> or ground. This 2R resistor connects to Node 2.</li>
                                <li>Node 2 is the output node V<sub>out</sub> (or input to an op-amp buffer). An R resistor connects Node 2 to Node 1.</li>
                                <li>At the B<sub>1</sub> input, a switch connects a 2R resistor to V<sub>ref</sub> or ground. This 2R connects to Node 1. An R resistor connects Node 1 to Node 0.</li>
                                <li>At the B<sub>0</sub> input, a switch connects a 2R resistor to V<sub>ref</sub> or ground. This 2R connects to Node 0. An R resistor connects Node 0 to one end of the terminating 2R resistor, the other end of which is grounded.</li>
                            </ul>
                            <img src="images/7_mark/Q9.jpg" alt="Block diagram of an R-2R Ladder DAC">
                        </div>

                        <p><strong>Working Principle and Output Voltage Derivation:</strong></p>
                        <p>The R-2R ladder network functions on the principle of precise current or voltage division. A key characteristic of this network, due to the terminating 2R resistor, is that the equivalent resistance looking from any node towards the LSB end is R. This property leads to a precise binary weighting of the contribution of each input bit to the final analog output.</p>
                        <p>Consider the output taken directly from the MSB node (before any buffer). By applying Thevenin's theorem repeatedly or by analyzing current division, it can be shown that each bit contributes a voltage component to the output that is weighted by a power of 2.</p>
                        <ul>
                            <li>The MSB (B<sub>n-1</sub>) contributes V<sub>ref</sub>/2 to the output if B<sub>n-1</sub>=1.</li>
                            <li>The next bit (B<sub>n-2</sub>) contributes V<sub>ref</sub>/4 to the output if B<sub>n-2</sub>=1.</li>
                            <li>And so on, down to the LSB (B<sub>0</sub>), which contributes V<sub>ref</sub>/2<sup>n</sup> if B<sub>0</sub>=1.</li>
                        </ul>
                        <p>The analog output voltage V<sub>out</sub> is the linear superposition of the voltages contributed by each bit that is set to '1'. The general formula for the output voltage is:</p>
                        <p><strong>V<sub>out</sub> = V<sub>ref</sub> ⋅ (B<sub>n-1</sub>/2<sup>1</sup> + B<sub>n-2</sub>/2<sup>2</sup> + B<sub>n-3</sub>/2<sup>3</sup> + ... + B<sub>0</sub>/2<sup>n</sup>)</strong></p>
                        <p>This can also be written as: <strong>V<sub>out</sub> = V<sub>ref</sub> ⋅ (Digital Input Value / 2<sup>n</sup>)</strong>, where "Digital Input Value" is the decimal equivalent of the binary input B<sub>n-1</sub>...B<sub>0</sub>.</p>
                        <p>If an op-amp is used in an inverting summing configuration with feedback resistor R<sub>f</sub>, the output will be an inverted and scaled version of this sum.</p>
                    </div>
                </div>
            </details>
            
            <details class="qa-block">
                <summary>10. Design a 4-bit synchronous BCD counter using JK flip-flops.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~2, Example Papers: S2023, W2021 (OR))</p>
                    <div class="answer-section">
                        <p>A **4-bit synchronous BCD (Binary Coded Decimal) counter** counts from decimal 0 (0000<sub>BCD</sub>) to 9 (1001<sub>BCD</sub>) and then resets to 0000 on the next clock pulse. This is a MOD-10 counter. Since it counts up to 9 (1001), it requires 4 flip-flops. Let their outputs be Q<sub>D</sub>, Q<sub>C</sub>, Q<sub>B</sub>, Q<sub>A</sub> (where Q<sub>D</sub> is the MSB and Q<sub>A</sub> is the LSB).</p>
                        <p><strong>Step 1: State Diagram & Transition Table</strong></p>
                        <p>The counter sequence is 0-1-2-3-4-5-6-7-8-9 and then back to 0. States corresponding to decimal 10 (1010) through 15 (1111) are unused and are treated as "don't care" (X) conditions, which can be used for simplification.</p>
                        <table>
                            <thead>
                                <tr><th colspan="4">Present State</th><th rowspan="2">Decimal</th><th colspan="4">Next State</th><th rowspan="2">Decimal</th><th colspan="2">FF<sub>D</sub></th><th colspan="2">FF<sub>C</sub></th><th colspan="2">FF<sub>B</sub></th><th colspan="2">FF<sub>A</sub></th></tr>
                                <tr><th>Q<sub>D</sub></th><th>Q<sub>C</sub></th><th>Q<sub>B</sub></th><th>Q<sub>A</sub></th><th>Q<sub>D(next)</sub></th><th>Q<sub>C(next)</sub></th><th>Q<sub>B(next)</sub></th><th>Q<sub>A(next)</sub></th><th>J<sub>D</sub></th><th>K<sub>D</sub></th><th>J<sub>C</sub></th><th>K<sub>C</sub></th><th>J<sub>B</sub></th><th>K<sub>B</sub></th><th>J<sub>A</sub></th><th>K<sub>A</sub></th></tr>
                            </thead>
                            <tbody>
                                <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>X</td><td>0</td><td>X</td><td>0</td><td>X</td><td>1</td><td>X</td></tr>
                                <tr><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>2</td><td>0</td><td>X</td><td>0</td><td>X</td><td>X</td><td>0</td><td>X</td><td>1</td></tr>
                                <tr><td>0</td><td>0</td><td>1</td><td>0</td><td>2</td><td>0</td><td>0</td><td>1</td><td>1</td><td>3</td><td>0</td><td>X</td><td>0</td><td>X</td><td>X</td><td>0</td><td>1</td><td>X</td></tr>
                                <tr><td>0</td><td>0</td><td>1</td><td>1</td><td>3</td><td>0</td><td>1</td><td>0</td><td>0</td><td>4</td><td>0</td><td>X</td><td>X</td><td>0</td><td>X</td><td>1</td><td>X</td><td>1</td></tr>
                                <tr><td>0</td><td>1</td><td>0</td><td>0</td><td>4</td><td>0</td><td>1</td><td>0</td><td>1</td><td>5</td><td>0</td><td>X</td><td>X</td><td>0</td><td>0</td><td>X</td><td>1</td><td>X</td></tr>
                                <tr><td>0</td><td>1</td><td>0</td><td>1</td><td>5</td><td>0</td><td>1</td><td>1</td><td>0</td><td>6</td><td>0</td><td>X</td><td>X</td><td>0</td><td>X</td><td>0</td><td>X</td><td>1</td></tr>
                                <tr><td>0</td><td>1</td><td>1</td><td>0</td><td>6</td><td>0</td><td>1</td><td>1</td><td>1</td><td>7</td><td>0</td><td>X</td><td>X</td><td>0</td><td>X</td><td>0</td><td>1</td><td>X</td></tr>
                                <tr><td>0</td><td>1</td><td>1</td><td>1</td><td>7</td><td>1</td><td>0</td><td>0</td><td>0</td><td>8</td><td>1</td><td>X</td><td>X</td><td>1</td><td>X</td><td>1</td><td>X</td><td>1</td></tr>
                                <tr><td>1</td><td>0</td><td>0</td><td>0</td><td>8</td><td>1</td><td>0</td><td>0</td><td>1</td><td>9</td><td>X</td><td>0</td><td>0</td><td>X</td><td>0</td><td>X</td><td>1</td><td>X</td></tr>
                                <tr><td>1</td><td>0</td><td>0</td><td>1</td><td>9</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>X</td><td>1</td><td>0</td><td>X</td><td>0</td><td>X</td><td>X</td><td>1</td></tr>
                                <tr><td>1</td><td>0</td><td>1</td><td>0</td><td>10</td><td>X</td><td>X</td><td>X</td><td>X</td><td>-</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr>
                                <tr><td>1</td><td>0</td><td>1</td><td>1</td><td>11</td><td>X</td><td>X</td><td>X</td><td>X</td><td>-</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr>
                                <tr><td>1</td><td>1</td><td>0</td><td>0</td><td>12</td><td>X</td><td>X</td><td>X</td><td>X</td><td>-</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr>
                                <tr><td>1</td><td>1</td><td>0</td><td>1</td><td>13</td><td>X</td><td>X</td><td>X</td><td>X</td><td>-</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr>
                                <tr><td>1</td><td>1</td><td>1</td><td>0</td><td>14</td><td>X</td><td>X</td><td>X</td><td>X</td><td>-</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr>
                                <tr><td>1</td><td>1</td><td>1</td><td>1</td><td>15</td><td>X</td><td>X</td><td>X</td><td>X</td><td>-</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr>
                            </tbody>
                        </table>
                        <p><strong>Step 2: K-Maps for J and K inputs for each flip-flop.</strong></p>
                        <div class="diagram-description">
                            <p>Using 4-variable K-maps (Q<sub>D</sub>Q<sub>C</sub>Q<sub>B</sub>Q<sub>A</sub>) and the don't cares for states 10-15:</p>
                            <ul>
                                <li><strong>J<sub>A</sub> = 1</strong>; <strong>K<sub>A</sub> = Q<sub>D</sub></strong> (A common simplification for BCD counters)
                                    <br/>(More rigorous K-map for K<sub>A</sub>=Σm(1,3,5,7,9)+d(...) might yield Q<sub>D</sub> or simply 1 if reset is handled by other stages)
                                </li>
                                <li><strong>J<sub>B</sub> = Q<sub>A</sub>Q<sub>D</sub>'</strong>; <strong>K<sub>B</sub> = Q<sub>A</sub></strong></li>
                                <li><strong>J<sub>C</sub> = Q<sub>A</sub>Q<sub>B</sub>Q<sub>D</sub>'</strong>; <strong>K<sub>C</sub> = Q<sub>A</sub>Q<sub>B</sub></strong></li>
                                <li><strong>J<sub>D</sub> = Q<sub>A</sub>Q<sub>B</sub>Q<sub>C</sub></strong>; <strong>K<sub>D</sub> = Q<sub>A</sub></strong></li>
                            </ul>
                            <img src="https://placehold.co/400x300/e2e8f0/4a5568?text=K-Maps+for+BCD+Counter" alt="K-Maps for BCD Counter">
                        </div>
                        <p><strong>Step 3: Logic Diagram</strong></p>
                        <div class="diagram-description">
                            <p>Draw four JK flip-flops (Q<sub>D</sub>, Q<sub>C</sub>, Q<sub>B</sub>, Q<sub>A</sub>). All share a common clock. Connect J and K inputs as per the derived equations using AND gates. For example:
                            <ul>
                                <li>FF<sub>A</sub>: J<sub>A</sub>=1 (connect to Vcc), K<sub>A</sub>=Q<sub>D</sub>.</li>
                                <li>FF<sub>B</sub>: J<sub>B</sub> is output of AND(Q<sub>A</sub>, Q<sub>D</sub>'), K<sub>B</sub> is Q<sub>A</sub>.</li>
                                <li>FF<sub>C</sub>: J<sub>C</sub> is output of AND(Q<sub>A</sub>, Q<sub>B</sub>, Q<sub>D</sub>'), K<sub>C</sub> is output of AND(Q<sub>A</sub>, Q<sub>B</sub>).</li>
                                <li>FF<sub>D</sub>: J<sub>D</sub> is output of AND(Q<sub>A</sub>, Q<sub>B</sub>, Q<sub>C</sub>), K<sub>D</sub> is Q<sub>A</sub>.</li>
                            </ul>
                            Outputs are Q<sub>D</sub>, Q<sub>C</sub>, Q<sub>B</sub>, Q<sub>A</sub>.</p>
                            <img src="images/7_mark/Q10.png" alt="BCD Counter Logic Diagram">
                        </div>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>11. Explain the characteristics of digital ICs in detail (Propagation delay, Power dissipation, Noise margin, Fan-in, Fan-out, Figure of Merit).</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~2, Example Papers: W2024, S2022)</p>
                    <div class="answer-section">
                        <p>Digital Integrated Circuits (ICs) are fundamental building blocks of digital systems. Their performance and suitability for different applications are evaluated based on several key electrical and operational characteristics. Understanding these characteristics is crucial for designing reliable and efficient digital circuits.</p>
                        <ol>
                            <li>
                                <p><strong>Propagation Delay (t<sub>p</sub>):</strong></p>
                                <ul>
                                    <li><strong>Definition:</strong> The time interval between the application of an input pulse (specifically, when the input crosses 50% of its logic swing) and the occurrence of the corresponding output pulse (when the output crosses 50% of its logic swing). It represents the time it takes for a signal change at the input to affect the output.</li>
                                    <li>Two values are often specified:
                                        <ul>
                                            <li><strong>t<sub>pLH</sub>:</strong> Propagation delay time for the output to change from Low to High.</li>
                                            <li><strong>t<sub>pHL</sub>:</strong> Propagation delay time for the output to change from High to Low.</li>
                                        </ul>
                                        The average propagation delay is often taken as t<sub>p</sub> = (t<sub>pLH</sub> + t<sub>pHL</sub>) / 2.
                                    </li>
                                    <li><strong>Significance:</strong> Directly determines the maximum operating speed or frequency of the digital circuit. Lower propagation delay means faster operation and higher possible clock frequencies.</li>
                                    <li><strong>Unit:</strong> Nanoseconds (ns) or picoseconds (ps).</li>
                                </ul>
                            </li>
                            <li>
                                <p><strong>Power Dissipation (P<sub>D</sub>):</strong></p>
                                <ul>
                                    <li><strong>Definition:</strong> The amount of electrical power consumed by the IC during its operation. It is typically calculated as the product of the supply voltage (V<sub>CC</sub> or V<sub>DD</sub>) and the average supply current (I<sub>CC(avg)</sub> or I<sub>DD(avg)</sub>).</li>
                                    <li>It includes two components:
                                        <ul>
                                            <li><strong>Static Power Dissipation:</strong> Power consumed when the inputs and outputs are not changing (i.e., the circuit is in a stable state). For some logic families like TTL, this can be significant. For CMOS, it's ideally very low (mainly due to leakage currents).</li>
                                            <li><strong>Dynamic Power Dissipation:</strong> Power consumed during the switching of logic states. This is due to the charging and discharging of internal and load capacitances, and also due to momentary short-circuit currents. It increases with operating frequency. For CMOS, P<sub>dynamic</sub> ≈ C ⋅ V<sub>DD</sub><sup>2</sup> ⋅ f.</li>
                                        </ul>
                                    </li>
                                    <li><strong>Significance:</strong> Affects battery life in portable devices, heat generation (requiring cooling mechanisms), and the overall power efficiency of the system. Lower power dissipation is generally desirable.</li>
                                    <li><strong>Unit:</strong> Milliwatts (mW) or microwatts (µW).</li>
                                </ul>
                            </li>
                            <li>
                                <p><strong>Noise Margin (NM):</strong></p>
                                <ul>
                                    <li><strong>Definition:</strong> The maximum unwanted electrical noise voltage that can be added to an input signal without causing an undesirable or erroneous change in the output state of the logic gate. It indicates the IC's immunity to noise.</li>
                                    <li><strong>Types:</strong>
                                        <ul>
                                            <li><strong>High-Level Noise Margin (NM<sub>H</sub>):</strong> NM<sub>H</sub> = V<sub>OH(min)</sub> - V<sub>IH(min)</sub>, where V<sub>OH(min)</sub> is the minimum guaranteed HIGH output voltage and V<sub>IH(min)</sub> is the minimum input voltage recognized as HIGH.</li>
                                            <li><strong>Low-Level Noise Margin (NM<sub>L</sub>):</strong> NM<sub>L</sub> = V<sub>IL(max)</sub> - V<sub>OL(max)</sub>, where V<sub>IL(max)</sub> is the maximum input voltage recognized as LOW and V<sub>OL(max)</sub> is the maximum guaranteed LOW output voltage.</li>
                                        </ul>
                                    </li>
                                    <li><strong>Significance:</strong> A larger noise margin implies better noise immunity and more reliable operation of the circuit in noisy environments.</li>
                                    <li><strong>Unit:</strong> Volts (V).</li>
                                </ul>
                            </li>
                            <li>
                                <p><strong>Fan-in:</strong></p>
                                <ul>
                                    <li><strong>Definition:</strong> The number of inputs that a single logic gate can accept. For example, a standard 2-input AND gate has a fan-in of 2.</li>
                                    <li><strong>Significance:</strong> Affects the complexity of logic functions that can be implemented by a single gate. Higher fan-in can reduce the total number of gates required for a complex function but may also lead to increased propagation delay or more complex internal gate structure.</li>
                                </ul>
                            </li>
                            <li>
                                <p><strong>Fan-out:</strong></p>
                                <ul>
                                    <li><strong>Definition:</strong> The maximum number of standard inputs of gates from the *same logic family* that the output of a single gate can drive reliably without its output voltage levels falling outside the specified logic level limits (V<sub>OH(min)</sub> and V<sub>OL(max)</sub>).</li>
                                    <li><strong>Significance:</strong> Critical for circuit design to ensure that a gate output is not overloaded. Overloading can lead to incorrect logic levels, increased propagation delays, or even damage to the driving gate. Fan-out is determined by the output current drive capability (I<sub>OH</sub>, I<sub>OL</sub>) of the driving gate and the input current requirements (I<sub>IH</sub>, I<sub>IL</sub>) of the driven gates.</li>
                                </ul>
                            </li>
                            <li>
                                <p><strong>Figure of Merit (Speed-Power Product):</strong></p>
                                <ul>
                                    <li><strong>Definition:</strong> A parameter used for comparing the overall performance trade-off of different logic families or gate designs. It is calculated as the product of the average propagation delay (t<sub>p</sub>) and the average power dissipation (P<sub>D</sub>) of a gate: Figure of Merit = t<sub>p</sub> × P<sub>D</sub>.</li>
                                    <li><strong>Significance:</strong> A lower figure of merit is generally better, indicating a more efficient gate that is either faster for a given power consumption, or consumes less power for a given speed. It represents the energy consumed per switching operation.</li>
                                    <li><strong>Unit:</strong> Picojoules (pJ) (since ns × mW = 10<sup>-9</sup>s × 10<sup>-3</sup>W = 10<sup>-12</sup>J).</li>
                                </ul>
                            </li>
                        </ol>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>12. Design a 3-bit synchronous UP/DOWN counter using T flip-flops.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~2, Example Papers: S2024 (OR), W2022)</p>
                    <div class="answer-section">
                        <p>A **3-bit synchronous UP/DOWN counter** counts in ascending order (000 to 111) when a mode control input M=0 (for UP) and in descending order (111 to 000) when M=1 (for DOWN). It requires 3 flip-flops. We will use T flip-flops. The T input determines if the flip-flop toggles (T=1) or holds its state (T=0) on the active clock edge.</p>
                        <p>Let the flip-flop outputs be Q<sub>C</sub>, Q<sub>B</sub>, Q<sub>A</sub> (Q<sub>C</sub> is MSB).</p>
                        <p><strong>Step 1: State Diagram & Transition Table</strong></p>
                        <p>The state transition table will include the present state (Q<sub>C</sub>Q<sub>B</sub>Q<sub>A</sub>), the mode input (M), the next state (Q<sub>C(next)</sub>Q<sub>B(next)</sub>Q<sub>A(next)</sub>), and the required T inputs (T<sub>C</sub>, T<sub>B</sub>, T<sub>A</sub>) for each flip-flop. T<sub>i</sub> = 1 if Q<sub>i(next)</sub> ≠ Q<sub>i</sub>, and T<sub>i</sub> = 0 if Q<sub>i(next)</sub> = Q<sub>i</sub>.</p>
                        <table>
                            <thead>
                                <tr><th>M</th><th>Q<sub>C</sub></th><th>Q<sub>B</sub></th><th>Q<sub>A</sub></th><th>Q<sub>C(next)</sub></th><th>Q<sub>B(next)</sub></th><th>Q<sub>A(next)</sub></th><th>T<sub>C</sub></th><th>T<sub>B</sub></th><th>T<sub>A</sub></th></tr>
                            </thead>
                            <tbody>
                                <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
                                <tr><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
                                <tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
                                <tr><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr>
                                <tr><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
                                <tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
                                <tr><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
                                <tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr>
                                <tr><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
                                <tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
                                <tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr>
                                <tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
                                <tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
                                <tr><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
                                <tr><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr>
                                <tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
                            </tbody>
                        </table>

                        <p><strong>Step 2: K-Maps for T inputs (T<sub>C</sub>, T<sub>B</sub>, T<sub>A</sub>)</strong><br/>
                        Inputs to K-maps are M, Q<sub>C</sub>, Q<sub>B</sub>, Q<sub>A</sub> (4-variable K-maps).</p>
                        <div class="diagram-description">
                            <p><strong>For T<sub>A</sub>:</strong> From the table, Q<sub>A</sub> always toggles regardless of M, Q<sub>C</sub>, Q<sub>B</sub>. So, <strong>T<sub>A</sub> = 1</strong>.</p>
                            <img src="images/7_mark/Q12_1.png" alt="K-Map for TA">
                            <p><strong>For T<sub>B</sub>:</strong> Plotting the K-map for T<sub>B</sub> from the table and simplifying gives: <strong>T<sub>B</sub> = M'Q<sub>A</sub> + MQ<sub>A</sub>' = M ⊕ Q<sub>A</sub></strong>.</p>
                            <img src="images/7_mark/Q12_2.png" alt="K-Map for TB">
                            <p><strong>For T<sub>C</sub>:</strong> Plotting the K-map for T<sub>C</sub> and simplifying gives: <strong>T<sub>C</sub> = M'Q<sub>B</sub>Q<sub>A</sub> + MQ<sub>B</sub>'Q<sub>A</sub>'</strong>.</p>
                            <img src="images/7_mark/Q12_3.png" alt="K-Map for TC">
                        </div>
                        
                        <p><strong>Step 3: Logic Diagram</strong></p>
                        <div class="diagram-description">
                            <p>The circuit consists of three T flip-flops (FF<sub>A</sub>, FF<sub>B</sub>, FF<sub>C</sub>). All share a common clock. The T inputs are connected as per the derived equations:</p>
                            <ul>
                                <li><strong>T<sub>A</sub>:</strong> Connected to Logic 1 (HIGH).</li>
                                <li><strong>T<sub>B</sub>:</strong> Connected to the output of an XOR gate whose inputs are M and Q<sub>A</sub>.</li>
                                <li><strong>T<sub>C</sub>:</strong> This requires more gates:
                                    <ul>
                                        <li>One AND gate for M'Q<sub>B</sub>Q<sub>A</sub> (Inputs: M' (from NOT M), Q<sub>B</sub>, Q<sub>A</sub>).</li>
                                        <li>Another AND gate for MQ<sub>B</sub>'Q<sub>A</sub>' (Inputs: M, Q<sub>B</sub>' (from NOT Q<sub>B</sub>), Q<sub>A</sub>' (from NOT Q<sub>A</sub>)).</li>
                                        <li>The outputs of these two AND gates are fed into an OR gate. The output of this OR gate is T<sub>C</sub>.</li>
                                    </ul>
                                </li>
                            </ul>
                            <p>Inputs to the circuit are M (Mode) and CLK. Outputs are Q<sub>C</sub>, Q<sub>B</sub>, Q<sub>A</sub>.</p>
                            <img src="images/7_mark/Q12.jpg" alt="Logic Diagram of a 3-bit Synchronous UP/DOWN Counter using T Flip-Flops">
                        </div>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>13. Explain the working of a Universal Shift Register with a neat block diagram and mode control.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~2, Example Papers: W2024 (OR), S2023)</p>
                    <div class="answer-section">
                        <p>A **Universal Shift Register** is a versatile sequential logic circuit that can perform multiple operations on the stored data, typically including: parallel load, serial shift right, serial shift left, and hold (no change). The specific operation performed at any given time is determined by mode control inputs (select lines).</p>
                        
                        <p><strong>Structure (Conceptual for an N-bit Universal Shift Register):</strong></p>
                        <p>It consists of N flip-flops (usually D-type for simplicity in controlling the next state). Each flip-flop's D input is fed by a multiplexer (MUX). This MUX selects what data will be loaded into the flip-flop on the next clock pulse, based on the mode control signals.</p>
                        
                        <p>For a 4-operation universal shift register (e.g., Hold, Shift Right, Shift Left, Parallel Load), each D flip-flop's input would typically be driven by a 4x1 MUX. The select lines for all these MUXes are common and are connected to the mode control inputs of the register.</p>

                        <p><strong>Inputs:</strong></p>
                        <ul>
                            <li><strong>Mode Control (S<sub>1</sub>, S<sub>0</sub>):</strong> Two select lines to choose one of four operations.</li>
                            <li><strong>Serial Input Right (SI<sub>R</sub>):</strong> Data input for shifting right (data enters from the left).</li>
                            <li><strong>Serial Input Left (SI<sub>L</sub>):</strong> Data input for shifting left (data enters from the right).</li>
                            <li><strong>Parallel Inputs (I<sub>n-1</sub> ... I<sub>0</sub>):</strong> N-bit data that can be loaded directly into the register.</li>
                            <li><strong>Clock (CLK):</strong> Synchronizes all operations.</li>
                            <li><strong>Clear (CLR) (Optional):</strong> To reset the register.</li>
                        </ul>
                        <p><strong>Outputs:</strong></p>
                        <ul>
                            <li><strong>Parallel Outputs (Q<sub>n-1</sub> ... Q<sub>0</sub>):</strong> The N-bit data currently stored in the register.</li>
                            <li>(Serial output can be taken from Q<sub>0</sub> for right shift or Q<sub>n-1</sub> for left shift).</li>
                        </ul>

                        <p><strong>Mode Control Table (Example for a 4-bit register Q<sub>3</sub>Q<sub>2</sub>Q<sub>1</sub>Q<sub>0</sub>):</strong></p>
                        <table>
                            <thead>
                                <tr><th>S<sub>1</sub></th><th>S<sub>0</sub></th><th>Operation</th><th>Action (Data loaded into Q<sub>i</sub> on next clock pulse)</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>0</td><td>0</td><td>Hold / No Change</td><td>Q<sub>i</sub> (current state of Q<sub>i</sub> is reloaded)</td></tr>
                                <tr><td>0</td><td>1</td><td>Shift Right</td><td>Q<sub>i+1</sub> (for Q<sub>0</sub>, Q<sub>1</sub>, Q<sub>2</sub>); SI<sub>R</sub> (for Q<sub>3</sub>, the MSB)</td></tr>
                                <tr><td>1</td><td>0</td><td>Shift Left</td><td>Q<sub>i-1</sub> (for Q<sub>3</sub>, Q<sub>2</sub>, Q<sub>1</sub>); SI<sub>L</sub> (for Q<sub>0</sub>, the LSB)</td></tr>
                                <tr><td>1</td><td>1</td><td>Parallel Load</td><td>I<sub>i</sub> (corresponding parallel input I<sub>i</sub> is loaded into Q<sub>i</sub>)</td></tr>
                            </tbody>
                        </table>

                        <div class="diagram-description">
                            <p><strong>Block Diagram (Conceptual for one bit-stage 'i' of an N-bit Universal Shift Register):</strong></p>
                            <p>Each bit-stage 'i' would consist of a D flip-flop (Q<sub>i</sub>) and a 4x1 MUX feeding its D input (D<sub>i</sub>).</p>
                            <ul>
                                <li>MUX Inputs:
                                    <ul>
                                        <li>Input 0: Q<sub>i</sub> (for Hold)</li>
                                        <li>Input 1: Q<sub>i+1</sub> (from FF to the left, or SI<sub>R</sub> if 'i' is MSB, for Shift Right)</li>
                                        <li>Input 2: Q<sub>i-1</sub> (from FF to the right, or SI<sub>L</sub> if 'i' is LSB, for Shift Left)</li>
                                        <li>Input 3: I<sub>i</sub> (Parallel data input for bit 'i')</li>
                                    </ul>
                                </li>
                                <li>MUX Select Lines: S<sub>1</sub>, S<sub>0</sub> (common mode control)</li>
                                <li>MUX Output: Connects to D<sub>i</sub> of the flip-flop.</li>
                                <li>Flip-Flop Output: Q<sub>i</sub>.</li>
                            </ul>
                            <p>An N-bit register would have N such stages, with appropriate interconnections for serial shifting and parallel loading, all sharing the CLK and mode control signals.</p>
                            <img src="images/7_mark/Q13.png" alt="Universal Shift Register Block Diagram (Conceptual)">
                        </div>

                        <p><strong>Working Principle:</strong></p>
                        <p>The mode control inputs (S<sub>1</sub>, S<sub>0</sub>) select which data path is connected to the D inputs of the flip-flops via the multiplexers. On the active clock edge:</p>
                        <ul>
                            <li><strong>Hold (e.g., S<sub>1</sub>S<sub>0</sub>=00):</strong> Each flip-flop's Q output is fed back to its own D input, so the stored data remains unchanged.</li>
                            <li><strong>Shift Right (e.g., S<sub>1</sub>S<sub>0</sub>=01):</strong> The output of each flip-flop is connected to the D input of the flip-flop to its immediate right. The leftmost flip-flop receives data from SI<sub>R</sub>. Data shifts one position to the right.</li>
                            <li><strong>Shift Left (e.g., S<sub>1</sub>S<sub>0</sub>=10):</strong> The output of each flip-flop is connected to the D input of the flip-flop to its immediate left. The rightmost flip-flop receives data from SI<sub>L</sub>. Data shifts one position to the left.</li>
                            <li><strong>Parallel Load (e.g., S<sub>1</sub>S<sub>0</sub>=11):</strong> The external parallel data inputs (I<sub>n-1</sub>...I<sub>0</sub>) are connected to the D inputs of their respective flip-flops, loading the entire N-bit word simultaneously.</li>
                        </ul>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>14. Implement a full adder circuit using two half adders and an OR gate. Draw the detailed circuit.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~2, Example Papers: S2023 (OR), W2021)</p>
                    <div class="answer-section">
                        <p>A **Full Adder** is a combinational circuit that performs the arithmetic sum of three input bits: A, B, and a Carry-in (C<sub>in</sub>) from a previous stage. It produces two outputs: a Sum (S) and a Carry-out (C<sub>out</sub>).</p>
                        <p>A **Half Adder (HA)** adds two single bits (X, Y) and produces a Sum (S<sub>HA</sub> = X ⊕ Y) and a Carry (C<sub>HA</sub> = X ⋅ Y).</p>
                        <p>A Full Adder can be constructed using two Half Adders and one OR gate.</p>
                        
                        <p><strong>Logic and Construction:</strong></p>
                        <p>The sum of three bits A, B, and C<sub>in</sub> can be performed in two steps:</p>
                        <ol>
                            <li>First, add A and B using a Half Adder (HA1). This produces an intermediate sum (S1) and an intermediate carry (C1).
                                <ul>
                                    <li>S1 = A ⊕ B</li>
                                    <li>C1 = A ⋅ B</li>
                                </ul>
                            </li>
                            <li>Next, add the intermediate sum S1 to the carry-in C<sub>in</sub> using a second Half Adder (HA2). This produces the final Sum (S) and another intermediate carry (C2).
                                <ul>
                                    <li>S = S1 ⊕ C<sub>in</sub> = (A ⊕ B) ⊕ C<sub>in</sub></li>
                                    <li>C2 = S1 ⋅ C<sub>in</sub> = (A ⊕ B) ⋅ C<sub>in</sub></li>
                                </ul>
                            </li>
                            <li>The final Carry-out (C<sub>out</sub>) of the Full Adder is generated if either HA1 produced a carry (C1) OR HA2 produced a carry (C2).
                                <ul>
                                    <li>C<sub>out</sub> = C1 + C2 = (A ⋅ B) + ((A ⊕ B) ⋅ C<sub>in</sub>)</li>
                                </ul>
                            </li>
                        </ol>
                        <p>This expression for C<sub>out</sub> can be shown to be equivalent to the standard Full Adder carry expression: C<sub>out</sub> = AB + BC<sub>in</sub> + AC<sub>in</sub>.</p>

                        <p><strong>Detailed Circuit Diagram:</strong></p>
                        <div class="diagram-description">
                            <p>The diagram would show:</p>
                            <ul>
                                <li>Three inputs: A, B, C<sub>in</sub>.</li>
                                <li>Two outputs: S (Final Sum), C<sub>out</sub> (Final Carry-out).</li>
                                <li><strong>Half Adder 1 (HA1):</strong>
                                    <ul>
                                        <li>Inputs: A, B.</li>
                                        <li>Outputs: S1 (A ⊕ B) and C1 (A ⋅ B). (Internally, HA1 has an XOR gate for S1 and an AND gate for C1).</li>
                                    </ul>
                                </li>
                                <li><strong>Half Adder 2 (HA2):</strong>
                                    <ul>
                                        <li>Inputs: S1 (from HA1) and C<sub>in</sub>.</li>
                                        <li>Outputs: S (Final Sum = S1 ⊕ C<sub>in</sub>) and C2 (S1 ⋅ C<sub>in</sub>). (Internally, HA2 has an XOR gate for S and an AND gate for C2).</li>
                                    </ul>
                                </li>
                                <li>An <strong>OR Gate:</strong>
                                    <ul>
                                        <li>Inputs: C1 (from HA1) and C2 (from HA2).</li>
                                        <li>Output: C<sub>out</sub> (Final Carry-out = C1 + C2).</li>
                                    </ul>
                                </li>
                            </ul>
                            <img src="images/7_mark/Q14.png" alt="Full Adder implemented using two Half Adders and an OR gate">
                        </div>
                        <p>This structure clearly demonstrates how the addition of three bits is broken down into two stages of two-bit addition, with the carries being combined appropriately.</p>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>15. Explain the operation of a dual-slope A/D converter with a block diagram and waveforms.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~2, Example Papers: S2024 (OR), W2022 (OR))</p>
                    <div class="answer-section">
                        <p>The **Dual-Slope Analog-to-Digital Converter (ADC)**, also known as a dual-slope integrating ADC, is a type of ADC known for its high accuracy, good noise rejection, and relatively simple design, although it has a slower conversion speed compared to other types like SAR or Flash ADCs.</p>
                        
                        <p><strong>Block Diagram Components:</strong></p>
                        <ul>
                            <li><strong>Integrator:</strong> An op-amp configured as an integrator, typically with an input resistor (R) and a feedback capacitor (C).</li>
                            <li><strong>Analog Switch:</strong> Controlled by the control logic, this switch selects either the unknown analog input voltage (V<sub>in</sub>) or a known negative reference voltage (-V<sub>ref</sub>) to be applied to the input of the integrator.</li>
                            <li><strong>Comparator:</strong> Compares the output voltage of the integrator (V<sub>int</sub>) with a fixed voltage, usually ground (0V). Its output changes state when V<sub>int</sub> crosses this reference.</li>
                            <li><strong>Counter:</strong> An N-bit digital counter that is driven by a stable clock source.</li>
                            <li><strong>Control Logic:</strong> Manages the overall conversion process, including controlling the analog switch, resetting and enabling/disabling the counter, and latching the final digital output.</li>
                            <li><strong>Clock Generator:</strong> Provides timing pulses for the counter and control logic.</li>
                        </ul>
                        <div class="diagram-description">
                            <p><strong>Block Diagram:</strong></p>
                            <p>The diagram shows V<sub>in</sub> and -V<sub>ref</sub> as inputs to an Analog Switch. The output of the switch goes to the Integrator (Op-amp with R and C). The Integrator's output (V<sub>int</sub>) goes to one input of the Comparator, with the other comparator input connected to ground. The Comparator's output goes to the Control Logic. The Control Logic also receives Clock pulses and controls the Analog Switch, the Counter (Reset, Enable), and an output Latch/Register which holds the final digital output from the Counter.</p>
                            <img src="images/7_mark/Q15_1.jpg" alt="Block Diagram of a Dual-Slope ADC">
                        </div>

                        <p><strong>Working Principle (Two Phases):</strong></p>
                        <p>The conversion process occurs in two distinct phases:</p>
                        <ol>
                            <li>
                                <p><strong>Phase 1: Integration of Input Voltage (Fixed Time T<sub>1</sub>)</strong></p>
                                <ul>
                                    <li>At the start of conversion, the counter is reset, and the integrator's output is usually zeroed (or set to a known starting point).</li>
                                    <li>The analog switch connects the unknown analog input voltage V<sub>in</sub> (assumed positive for this explanation) to the input of the integrator.</li>
                                    <li>The integrator begins to integrate V<sub>in</sub>. Its output voltage (V<sub>int</sub>) ramps up or down linearly with a slope proportional to V<sub>in</sub>. If V<sub>in</sub> is positive and the integrator is inverting, V<sub>int</sub> will ramp downwards: V<sub>int</sub> = -(V<sub>in</sub>/RC) ⋅ t.</li>
                                    <li>This integration continues for a fixed period of time, T<sub>1</sub>. T<sub>1</sub> is determined by allowing the counter to count up to its maximum value (e.g., 2<sup>N</sup> clock pulses for an N-bit counter).</li>
                                    <li>At the end of T<sub>1</sub>, the voltage reached by the integrator is: <strong>V<sub>peak</sub> = -(V<sub>in</sub>/RC) ⋅ T<sub>1</sub></strong>.</li>
                                </ul>
                            </li>
                            <li>
                                <p><strong>Phase 2: De-integration with Reference Voltage (Variable Time T<sub>2</sub>)</strong></p>
                                <ul>
                                    <li>At the beginning of Phase 2, the control logic switches the integrator's input from V<sub>in</sub> to a known, stable, negative reference voltage, -V<sub>ref</sub>.</li>
                                    <li>Simultaneously, the counter is reset and starts counting again from zero.</li>
                                    <li>The integrator now integrates -V<sub>ref</sub>. Since -V<sub>ref</sub> has the opposite polarity to V<sub>in</sub> (assuming V<sub>in</sub> was positive), the integrator's output V<sub>int</sub> will ramp in the opposite direction (upwards) from V<sub>peak</sub> towards zero, with a constant slope proportional to -V<sub>ref</sub>: dV<sub>int</sub>/dt = -(-V<sub>ref</sub>/RC) = V<sub>ref</sub>/RC.</li>
                                    <li>The comparator continuously monitors V<sub>int</sub>. When V<sub>int</sub> reaches zero volts, the comparator changes state.</li>
                                    <li>This change in the comparator's output signals the control logic to stop the counter. The time taken for V<sub>int</sub> to return to zero from V<sub>peak</sub> is T<sub>2</sub>. The value in the counter at this point is proportional to T<sub>2</sub>.</li>
                                    <li>The change in integrator voltage during T<sub>2</sub> is: |V<sub>peak</sub>| = (V<sub>ref</sub>/RC) ⋅ T<sub>2</sub>.</li>
                                </ul>
                            </li>
                        </ol>
                        <p><strong>Derivation of Digital Output:</strong></p>
                        <p>Since the magnitude of the voltage change during Phase 1 is equal to the magnitude of the voltage change during Phase 2:</p>
                        <p>|(V<sub>in</sub>/RC) ⋅ T<sub>1</sub>| = |(V<sub>ref</sub>/RC) ⋅ T<sub>2</sub>|</p>
                        <p>V<sub>in</sub> ⋅ T<sub>1</sub> = V<sub>ref</sub> ⋅ T<sub>2</sub></p>
                        <p>Therefore, <strong>V<sub>in</sub> = V<sub>ref</sub> ⋅ (T<sub>2</sub> / T<sub>1</sub>)</strong></p>
                        <p>Since V<sub>ref</sub> and T<sub>1</sub> (fixed duration, e.g., 2<sup>N</sup> clock counts) are known constants, V<sub>in</sub> is directly proportional to T<sub>2</sub>. The count in the counter at the end of T<sub>2</sub> is the digital representation of V<sub>in</sub>.</p>

                        <div class="diagram-description">
                            <p><strong>Waveforms:</strong></p>
                            <p>A timing diagram would show:</p>
                            <ul>
                                <li><strong>Integrator Output (V<sub>int</sub>):</strong> Starts at 0, ramps linearly downwards (proportional to V<sub>in</sub>) for a fixed time T<sub>1</sub> to reach V<sub>peak</sub>. Then, it ramps linearly upwards (with a fixed slope proportional to V<sub>ref</sub>) for a variable time T<sub>2</sub> until it reaches 0V.</li>
                                <li><strong>Comparator Output:</strong> Changes state when V<sub>int</sub> crosses 0V at the end of T<sub>2</sub>.</li>
                                <li><strong>Counter:</strong> Shows counting up to a fixed value during T<sub>1</sub>, then resetting and counting up during T<sub>2</sub> until stopped by the comparator.</li>
                            </ul>
                            <img src="images/7_mark/Q15_2.png" alt="Waveforms for Dual-Slope ADC operation">
                        </div>
                        <p><strong>Advantages:</strong> High accuracy (less dependent on precise values of R and C, as they appear in both integration phases and cancel out, as long as they are stable during one conversion cycle), excellent noise rejection (due to the integration process averaging out noise), good linearity.</p>
                        <p><strong>Disadvantages:</strong> Slow conversion speed (conversion time = T<sub>1</sub> + T<sub>2</sub>, which can be relatively long, especially for high resolution).</p>
                    </div>
                </div>
            </details>
            
            <details class="qa-block">
                <summary>16. Design a circuit to implement a given state diagram using D flip-flops (or JK flip-flops).</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~1, Example Papers: S2023)</p>
                    <div class="answer-section">
                        <p>Designing a sequential circuit from a state diagram involves several steps: state assignment, creating a state transition/excitation table, deriving flip-flop input equations, deriving output equations (if any), and finally drawing the logic circuit.</p>
                        <p><strong>Example: Implement the following State Diagram using D Flip-Flops.</strong></p>
                        <p>Assume a state diagram with 3 states (S0, S1, S2), 1 input (X), and 1 Moore-type output (Y, where output depends only on the current state).</p>
                        <ul>
                            <li><strong>S0 (Y=0):</strong> If X=0, next state is S0. If X=1, next state is S1.</li>
                            <li><strong>S1 (Y=0):</strong> If X=0, next state is S2. If X=1, next state is S0.</li>
                            <li><strong>S2 (Y=1):</strong> If X=0, next state is S2. If X=1, next state is S1.</li>
                        </ul>

                        <p><strong>Step 1: State Assignment.</strong></p>
                        <p>Since there are 3 states, we need at least log<sub>2</sub>(3) flip-flops. So, 2 flip-flops are required. Let their outputs be Q<sub>B</sub> and Q<sub>A</sub>.</p>
                        <p>Possible state assignments:</p>
                        <ul>
                            <li>S0 = 00 (Q<sub>B</sub>=0, Q<sub>A</sub>=0)</li>
                            <li>S1 = 01 (Q<sub>B</sub>=0, Q<sub>A</sub>=1)</li>
                            <li>S2 = 10 (Q<sub>B</sub>=1, Q<sub>A</sub>=0)</li>
                        </ul>
                        <p>The state 11 is unused and can be treated as a "don't care" condition.</p>

                        <p><strong>Step 2: State Transition and Excitation Table (for D Flip-Flops).</strong></p>
                        <p>For D flip-flops, the input D<sub>i</sub> is simply equal to the desired next state Q<sub>i(next)</sub>.</p>
                        <table>
                            <thead>
                                <tr><th colspan="3">Present State</th><th rowspan="2">Input X</th><th colspan="3">Next State</th><th colspan="2">D FF Inputs</th><th rowspan="2">Output Y</th></tr>
                                <tr><th>State</th><th>Q<sub>B</sub></th><th>Q<sub>A</sub></th><th>State</th><th>Q<sub>B(next)</sub></th><th>Q<sub>A(next)</sub></th><th>D<sub>B</sub> (=Q<sub>B(next)</sub>)</th><th>D<sub>A</sub> (=Q<sub>A(next)</sub>)</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>S0</td><td>0</td><td>0</td><td>0</td><td>S0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
                                <tr><td>S0</td><td>0</td><td>0</td><td>1</td><td>S1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>
                                <tr><td>S1</td><td>0</td><td>1</td><td>0</td><td>S2</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
                                <tr><td>S1</td><td>0</td><td>1</td><td>1</td><td>S0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
                                <tr><td>S2</td><td>1</td><td>0</td><td>0</td><td>S2</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
                                <tr><td>S2</td><td>1</td><td>0</td><td>1</td><td>S1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr>
                                <tr><td>-</td><td>1</td><td>1</td><td>0</td><td>-</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr>
                                <tr><td>-</td><td>1</td><td>1</td><td>1</td><td>-</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr>
                            </tbody>
                        </table>

                        <p><strong>Step 3: K-Maps for D<sub>B</sub>, D<sub>A</sub>, and Output Y.</strong></p>
                        <p>The inputs to the K-maps are Q<sub>B</sub>, Q<sub>A</sub>, and X.</p>
                        <div class="diagram-description">
                            <p><strong>K-Map for D<sub>B</sub> (Q<sub>B(next)</sub>):</strong> Σm(Q<sub>B</sub>Q<sub>A</sub>X: 010, 100) + d(110, 111)</p>
                            <img src="https://placehold.co/350x250/e2e8f0/4a5568?text=K-Map+for+DB" alt="K-Map for DB">
                            <p>Simplified: <strong>D<sub>B</sub> = Q<sub>B</sub>X' + Q<sub>A</sub>X'</strong>  (or X'(Q<sub>B</sub>+Q<sub>A</sub>))</p>

                            <p><strong>K-Map for D<sub>A</sub> (Q<sub>A(next)</sub>):</strong> Σm(Q<sub>B</sub>Q<sub>A</sub>X: 001, 101) + d(110, 111)</p>
                            <img src="https://placehold.co/350x250/e2e8f0/4a5568?text=K-Map+for+DA" alt="K-Map for DA">
                            <p>Simplified: <strong>D<sub>A</sub> = Q<sub>B</sub>'X + Q<sub>A</sub>'X</strong> (or X(Q<sub>B</sub>'+Q<sub>A</sub>'))</p>

                            <p><strong>K-Map for Output Y (Moore type, depends only on Q<sub>B</sub>, Q<sub>A</sub>):</strong> Y=1 for state S2 (10). Y=0 for S0(00), S1(01). Don't cares for state 11.</p>
                            <img src="https://placehold.co/300x200/e2e8f0/4a5568?text=K-Map+for+Y" alt="K-Map for Y">
                            <p>Simplified: <strong>Y = Q<sub>B</sub>Q<sub>A</sub>'</strong></p>
                        </div>

                        <p><strong>Step 4: Logic Diagram.</strong></p>
                        <div class="diagram-description">
                            <p>The circuit consists of two D flip-flops (FF<sub>B</sub> and FF<sub>A</sub>) and combinational logic for D<sub>B</sub>, D<sub>A</sub>, and Y.</p>
                            <ul>
                                <li>FF<sub>B</sub>: D<sub>B</sub> input connected to the output of an OR gate whose inputs are (AND(Q<sub>B</sub>, X')) and (AND(Q<sub>A</sub>, X')).</li>
                                <li>FF<sub>A</sub>: D<sub>A</sub> input connected to the output of an OR gate whose inputs are (AND(Q<sub>B</sub>', X)) and (AND(Q<sub>A</sub>', X)).</li>
                                <li>Output Y: Connected to the output of an AND gate with inputs Q<sub>B</sub> and Q<sub>A</sub>'.</li>
                                <li>Both flip-flops share a common clock signal.</li>
                            </ul>
                            <img src="https://placehold.co/600x400/e2e8f0/4a5568?text=State+Machine+Logic+Diagram" alt="State Machine Logic Diagram using D Flip-Flops">
                        </div>
                        <p><strong>If using JK Flip-Flops:</strong> The excitation table would include columns for J<sub>B</sub>, K<sub>B</sub>, J<sub>A</sub>, K<sub>A</sub>, derived using the JK excitation rules (Q→Q<sub>next</sub>: 00→0X, 01→1X, 10→X1, 11→X0). K-maps would then be used to simplify these J and K input equations.</p>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>17. Compare different logic families (TTL, CMOS, ECL) based on various parameters in detail.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~1, Example Papers: W2023)</p>
                    <div class="answer-section">
                        <p>TTL (Transistor-Transistor Logic), CMOS (Complementary Metal-Oxide-Semiconductor), and ECL (Emitter-Coupled Logic) are three major digital logic families, each with distinct characteristics, advantages, and disadvantages. Here's a detailed comparison based on several key parameters:</p>
                        
                        <table>
                            <thead>
                                <tr><th>Parameter / Feature</th><th>TTL (Transistor-Transistor Logic)</th><th>CMOS (Complementary Metal-Oxide-Semiconductor)</th><th>ECL (Emitter-Coupled Logic)</th></tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>1. Basic Switching Element</strong></td>
                                    <td>Bipolar Junction Transistors (BJTs). Input stage often uses a multi-emitter BJT. Output stage is typically a totem-pole configuration.</td>
                                    <td>Metal-Oxide-Semiconductor Field-Effect Transistors (MOSFETs), specifically using complementary pairs of PMOS (P-channel) and NMOS (N-channel) transistors.</td>
                                    <td>Bipolar Junction Transistors (BJTs) configured as a differential amplifier. Transistors operate primarily in the active region, avoiding deep saturation.</td>
                                </tr>
                                <tr>
                                    <td><strong>2. Static Power Dissipation</strong></td>
                                    <td>Moderate to High. Standard TTL gates consume power even when not switching (static dissipation) due to transistor biasing currents. Typically 1-20 mW per gate.</td>
                                    <td>Extremely Low. Ideally, no DC path exists between V<sub>DD</sub> and Ground when inputs are stable, so static power is mainly due to leakage currents (µW or nW range).</td>
                                    <td>Very High. ECL gates maintain a constant current flow through the differential amplifier, resulting in high static power dissipation regardless of switching activity (typically 25-75 mW per gate).</td>
                                </tr>
                                <tr>
                                    <td><strong>3. Dynamic Power Dissipation</strong></td>
                                    <td>Increases with switching frequency. Current spikes occur during output transitions.</td>
                                    <td>Dominant form of power consumption. Proportional to switching frequency, supply voltage squared, and load capacitance (P<sub>dynamic</sub> ≈ C ⋅ V<sub>DD</sub><sup>2</sup> ⋅ f).</td>
                                    <td>Relatively constant, as current draw doesn't change much with switching. The high static power is the main component.</td>
                                </tr>
                                <tr>
                                    <td><strong>4. Supply Voltage (V<sub>CC</sub> / V<sub>DD</sub> / V<sub>EE</sub>)</strong></td>
                                    <td>Typically a precise +5V supply for standard 74xx series. Less tolerant to variations.</td>
                                    <td>Offers a wide operating voltage range (e.g., older 4000 series: 3V to 18V; modern HC/HCT/LV series: 1.8V to 5.5V or lower). More tolerant to supply variations.</td>
                                    <td>Typically requires a negative supply voltage (e.g., V<sub>EE</sub> = -5.2V, with V<sub>CC</sub> at Ground) or sometimes dual supplies. This helps in maintaining constant current and improving noise immunity.</td>
                                </tr>
                                <tr>
                                    <td><strong>5. Propagation Delay (Speed)</strong></td>
                                    <td>Moderate to fast (e.g., standard TTL ~10 ns; Schottky sub-families like 74AS down to ~1.5 ns).</td>
                                    <td>Speed is highly dependent on supply voltage and specific CMOS series. Can range from slower than TTL (older series, low V<sub>DD</sub>) to much faster (modern advanced CMOS, sub-nanosecond to few ns).</td>
                                    <td>Extremely Low (Fastest logic family). Propagation delays can be less than 1 ns (e.g., 0.2 ns to 2 ns). This is because transistors do not saturate.</td>
                                </tr>
                                <tr>
                                    <td><strong>6. Noise Margin</strong></td>
                                    <td>Good. Typically around 0.4V for both NM<sub>H</sub> and NM<sub>L</sub> for standard TTL. More susceptible to power supply noise.</td>
                                    <td>Excellent. Typically a larger fraction of the supply voltage (e.g., for HC series, often close to 0.3V<sub>DD</sub> to 0.5V<sub>DD</sub>), providing high immunity to voltage noise.</td>
                                    <td>Fair to Good. The voltage swing is small, but the differential nature of the internal circuitry provides good common-mode noise rejection. However, absolute noise margin can be lower than CMOS.</td>
                                </tr>
                                <tr>
                                    <td><strong>7. Fan-out</strong></td>
                                    <td>Moderate. A standard TTL output can typically drive 10 standard TTL inputs of the same family. Limited by current sourcing/sinking.</td>
                                    <td>Very high when driving other CMOS inputs due to high input impedance (MOSFET gates). Limited by capacitive loading which affects speed.</td>
                                    <td>Moderate to High. Emitter-follower outputs provide good current driving capability. Typically can drive 25 to 50 ECL loads.</td>
                                </tr>
                                <tr>
                                    <td><strong>8. Logic Levels & Swing</strong></td>
                                    <td>V<sub>OL(max)</sub> ≈ 0.4V, V<sub>OH(min)</sub> ≈ 2.4V. Relatively large logic swing but not rail-to-rail.</td>
                                    <td>V<sub>OL(max)</sub> ≈ 0V, V<sub>OH(min)</sub> ≈ V<sub>DD</sub>. Rail-to-rail output swing (outputs swing very close to supply rails).</td>
                                    <td>Small logic swing (e.g., ~0.8V, typically between -0.9V and -1.7V for a -5.2V supply). Outputs are often complementary (both true and inverted outputs available).</td>
                                </tr>
                                 <tr>
                                    <td><strong>9. Switching Transients</strong></td>
                                    <td>Generates significant current spikes on power lines during output transitions (totem-pole output). Requires good decoupling.</td>
                                    <td>Generates current spikes during switching due to charging/discharging capacitances and momentary conduction of both PMOS and NMOS. Requires decoupling.</td>
                                    <td>Generates relatively low switching noise on power lines because current is steered rather than switched on/off, leading to more constant current draw.</td>
                                </tr>
                                <tr>
                                    <td><strong>10. Packing Density</strong></td>
                                    <td>Lower due to BJT size and need for resistors.</td>
                                    <td>Highest due to small MOSFET size, making it ideal for LSI/VLSI.</td>
                                    <td>Moderate, uses BJTs and resistors.</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>18. Explain memory organization and how to expand memory capacity (e.g., 1Kx8 to 2Kx8) and word size (e.g., 1Kx4 to 1Kx8) using memory chips.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~1, Example Papers: S2022)</p>
                    <div class="answer-section">
                        <p><strong>Memory Organization Basics:</strong></p>
                        <p>Semiconductor memories are organized as an array of storage cells, where each cell can store one bit of information (0 or 1). The overall organization is typically described by its capacity in terms of words and word size.</p>
                        <ul>
                            <li><strong>Word:</strong> A group of bits that are accessed (read or written) simultaneously.</li>
                            <li><strong>Word Size (or Width):</strong> The number of bits in a word (e.g., 8 bits, 16 bits, 32 bits). This usually corresponds to the number of data lines.</li>
                            <li><strong>Capacity:</strong> The total number of bits that can be stored in the memory chip. It's often expressed as M words × N bits per word (e.g., 1K × 8 means 1024 words, each 8 bits wide, for a total capacity of 8192 bits).</li>
                            <li><strong>Address Lines:</strong> These lines are used to select a specific word location (address) within the memory. If a memory has M words, it requires log<sub>2</sub>M address lines. For example, a 1K (1024) word memory needs log<sub>2</sub>1024 = 10 address lines (A<sub>0</sub> to A<sub>9</sub>).</li>
                            <li><strong>Data Lines:</strong> These are bidirectional lines used to transfer data to (write) or from (read) the selected memory location. The number of data lines is equal to the word size.</li>
                            <li><strong>Control Lines:</strong> These signals manage the memory operations:
                                <ul>
                                    <li><strong>Chip Select (CS) or Chip Enable (CE):</strong> Activates or deactivates the memory chip. Often active-low (CS').</li>
                                    <li><strong>Read/Write (R/W' or WE'):</strong> Specifies the operation. R/W'=1 for read, R/W'=0 for write. Or, separate Read Enable (RE') and Write Enable (WE') signals might be used.</li>
                                    <li><strong>Output Enable (OE') (Optional):</strong> Controls the output buffers of the memory chip, enabling data to be placed on the data bus during a read operation. Often active-low.</li>
                                </ul>
                            </li>
                        </ul>

                        <hr class="section-divider"/>
                        <p><strong>Expanding Memory Capacity (Increasing the Number of Words)</strong></p>
                        <p>This involves using multiple memory chips to increase the total number of addressable locations while keeping the word size the same.</p>
                        <p><strong>Example: Expand a 1K × 8 memory system to a 2K × 8 memory system using two 1K × 8 memory chips.</strong></p>
                        <ul>
                            <li><strong>Requirement:</strong> 2K words = 2048 words. Word size = 8 bits.
                                Total address lines needed for 2048 locations = log<sub>2</sub>2048 = 11 address lines (e.g., A<sub>0</sub> to A<sub>10</sub>).
                            </li>
                            <li><strong>Available Chips:</strong> Two 1K × 8 chips (Chip 0 and Chip 1). Each chip has:
                                <ul>
                                    <li>10 address lines (to select one of its 1024 internal locations).</li>
                                    <li>8 data lines.</li>
                                    <li>Control inputs like CS', R/W'.</li>
                                </ul>
                            </li>
                            <li><strong>Connection Strategy:</strong>
                                <ul>
                                    <li><strong>Address Lines A<sub>0</sub>-A<sub>9</sub> (System):</strong> These 10 lines are connected in parallel to the corresponding address inputs of BOTH Chip 0 and Chip 1. These lines select a specific location *within* each chip.</li>
                                    <li><strong>Address Line A<sub>10</sub> (System):</strong> This highest-order system address line is used for chip selection. It distinguishes between the two 1K blocks.
                                        <ul>
                                            <li>A<sub>10</sub> = 0 can be used to select Chip 0 (e.g., A<sub>10</sub> connected to an inverter, whose output goes to CS<sub>0</sub>' of Chip 0).</li>
                                            <li>A<sub>10</sub> = 1 can be used to select Chip 1 (e.g., A<sub>10</sub> connected directly to CS<sub>1</sub>' of Chip 1, assuming active-low CS, or use a 1-to-2 decoder).
                                            Effectively, Chip 0 handles addresses 00000000000 (0) to 01111111111 (1023), and Chip 1 handles 10000000000 (1024) to 11111111111 (2047).</li>
                                        </ul>
                                    </li>
                                    <li><strong>Data Lines D<sub>0</sub>-D<sub>7</sub> (System):</strong> Connected in parallel to the data lines of BOTH Chip 0 and Chip 1. Since only one chip is selected at a time, only that chip will drive or read from the data bus.</li>
                                    <li><strong>Control Lines (R/W', OE' System):</strong> Connected in parallel to the corresponding control inputs of BOTH Chip 0 and Chip 1.</li>
                                </ul>
                            </li>
                        </ul>
                        <div class="diagram-description">
                            <p>Diagram would show two 1Kx8 memory blocks. System address lines A0-A9 go to both. System A10 goes to a decoder (or logic using A10 and its inverse) to generate CS0' and CS1'. System data lines D0-D7 are common to both. R/W' and OE' lines are common to both.</p>
                            <img src="images/7_mark/Q18_1.png" alt="Memory Capacity Expansion Diagram">
                        </div>

                        <hr class="section-divider"/>
                        <p><strong>Expanding Word Size (Increasing the Number of Bits per Word)</strong></p>
                        <p>This involves using multiple memory chips to increase the width of each memory word, while keeping the total number of addressable locations the same.</p>
                        <p><strong>Example: Expand a 1K × 4 memory system to a 1K × 8 memory system using two 1K × 4 memory chips.</strong></p>
                        <ul>
                            <li><strong>Requirement:</strong> 1K words = 1024 words. Word size = 8 bits.
                                Total address lines needed for 1024 locations = log<sub>2</sub>1024 = 10 address lines (A<sub>0</sub> to A<sub>9</sub>).
                            </li>
                            <li><strong>Available Chips:</strong> Two 1K × 4 chips (Chip 0 and Chip 1). Each chip has:
                                <ul>
                                    <li>10 address lines.</li>
                                    <li>4 data lines.</li>
                                    <li>Control inputs like CS', R/W'.</li>
                                </ul>
                            </li>
                            <li><strong>Connection Strategy:</strong>
                                <ul>
                                    <li><strong>Address Lines A<sub>0</sub>-A<sub>9</sub> (System):</strong> Connected in parallel to the corresponding address inputs of BOTH Chip 0 and Chip 1. This ensures that the same location in both chips is accessed simultaneously.</li>
                                    <li><strong>Chip Select (CS' System):</strong> Connected in parallel to the CS' inputs of BOTH Chip 0 and Chip 1. Both chips are selected (enabled) at the same time.</li>
                                    <li><strong>Data Lines (System):</strong> The 8-bit system data bus is split.
                                        <ul>
                                            <li>System data lines D<sub>0</sub>-D<sub>3</sub> (lower 4 bits) connect to the 4 data lines of Chip 0.</li>
                                            <li>System data lines D<sub>4</sub>-D<sub>7</sub> (upper 4 bits) connect to the 4 data lines of Chip 1.</li>
                                        </ul>
                                    </li>
                                    <li><strong>Control Lines (R/W', OE' System):</strong> Connected in parallel to the corresponding control inputs of BOTH Chip 0 and Chip 1, so they are read or written simultaneously.</li>
                                </ul>
                            </li>
                            <li><strong>Operation:</strong> When an address is selected by A<sub>0</sub>-A<sub>9</sub> and CS' is active, both chips are enabled. Chip 0 handles the lower nibble (4 bits) of the 8-bit word, and Chip 1 handles the upper nibble. Together, they form one 8-bit word at the selected address.</li>
                        </ul>
                        <div class="diagram-description">
                            <p>Diagram would show two 1Kx4 memory blocks. System address lines A0-A9 go to both. System CS' goes to both. System data lines D0-D3 connect to Chip 0; D4-D7 connect to Chip 1. R/W' and OE' lines are common to both.</p>
                            <img src="images/7_mark/Q18_2.png" alt="Memory Word Size Expansion Diagram">
                        </div>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>19. Design a MOD-5 synchronous counter using D flip-flops.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~1, Example Papers: W2024)</p>
                    <div class="answer-section">
                        <p>A **MOD-5 synchronous counter** is a sequential circuit that cycles through five distinct states and then repeats. Typically, these states represent decimal counts 0, 1, 2, 3, 4. To represent 5 states, we need at least log<sub>2</sub>(5) flip-flops, which means 3 flip-flops are required (since 2<sup>2</sup>=4 is too few, and 2<sup>3</sup>=8 is sufficient). Let the flip-flop outputs be Q<sub>C</sub>, Q<sub>B</sub>, Q<sub>A</sub> (Q<sub>C</sub> being MSB).</p>
                        <p>We will use D flip-flops, where the D input determines the next state of the flip-flop (Q<sub>next</sub> = D).</p>

                        <p><strong>Step 1: State Diagram and State Transition Table</strong></p>
                        <p>The desired sequence is 000 → 001 → 010 → 011 → 100 → 000 (repeats).</p>
                        <p>States 101 (5), 110 (6), and 111 (7) are unused and can be treated as "don't care" (X) conditions for simplification.</p>
                        <table>
                            <thead>
                                <tr><th colspan="3">Present State</th><th rowspan="2">Decimal Equiv.</th><th colspan="3">Next State</th><th rowspan="2">Decimal Equiv.</th><th colspan="3">D Flip-Flop Inputs</th></tr>
                                <tr><th>Q<sub>C</sub></th><th>Q<sub>B</sub></th><th>Q<sub>A</sub></th><th>Q<sub>C(next)</sub></th><th>Q<sub>B(next)</sub></th><th>Q<sub>A(next)</sub></th><th>D<sub>C</sub> (=Q<sub>C(next)</sub>)</th><th>D<sub>B</sub> (=Q<sub>B(next)</sub>)</th><th>D<sub>A</sub> (=Q<sub>A(next)</sub>)</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
                                <tr><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>2</td><td>0</td><td>1</td><td>0</td></tr>
                                <tr><td>0</td><td>1</td><td>0</td><td>2</td><td>0</td><td>1</td><td>1</td><td>3</td><td>0</td><td>1</td><td>1</td></tr>
                                <tr><td>0</td><td>1</td><td>1</td><td>3</td><td>1</td><td>0</td><td>0</td><td>4</td><td>1</td><td>0</td><td>0</td></tr>
                                <tr><td>1</td><td>0</td><td>0</td><td>4</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
                                <tr><td>1</td><td>0</td><td>1</td><td>5</td><td>X</td><td>X</td><td>X</td><td>-</td><td>X</td><td>X</td><td>X</td></tr>
                                <tr><td>1</td><td>1</td><td>0</td><td>6</td><td>X</td><td>X</td><td>X</td><td>-</td><td>X</td><td>X</td><td>X</td></tr>
                                <tr><td>1</td><td>1</td><td>1</td><td>7</td><td>X</td><td>X</td><td>X</td><td>-</td><td>X</td><td>X</td><td>X</td></tr>
                            </tbody>
                        </table>

                        <p><strong>Step 2: K-Maps for D Inputs (D<sub>C</sub>, D<sub>B</sub>, D<sub>A</sub>)</strong></p>
                        <p>The inputs to the K-maps are the present state variables Q<sub>C</sub>, Q<sub>B</sub>, Q<sub>A</sub>.</p>
                        <div class="diagram-description">
                            <p><strong>K-Map for D<sub>A</sub> (=Q<sub>A(next)</sub>):</strong> Σm(0,2) + d(5,6,7)</p>
                            <img src="images/7_mark/Q19_1.png" alt="K-Map for DA (MOD-5 Counter)">
                            <p>Grouping gives: <strong>D<sub>A</sub> = Q<sub>C</sub>'Q<sub>B</sub>'</strong> (or Q&#773;<sub>C</sub>Q&#773;<sub>B</sub>)</p>

                            <p><strong>K-Map for D<sub>B</sub> (=Q<sub>B(next)</sub>):</strong> Σm(1,2) + d(5,6,7)</p>
                            <img src="images/7_mark/Q19_2.png" alt="K-Map for DB (MOD-5 Counter)">
                            <p>Grouping gives: <strong>D<sub>B</sub> = Q<sub>C</sub>'Q<sub>A</sub></strong> (or Q&#773;<sub>C</sub>Q<sub>A</sub>)</p>

                            <p><strong>K-Map for D<sub>C</sub> (=Q<sub>C(next)</sub>):</strong> Σm(3) + d(5,6,7)</p>
                            <img src="images/7_mark/Q19_3.png" alt="K-Map for DC (MOD-5 Counter)">
                            <p>Grouping gives: <strong>D<sub>C</sub> = Q<sub>C</sub>'Q<sub>B</sub>Q<sub>A</sub></strong> (or Q&#773;<sub>C</sub>Q<sub>B</sub>Q<sub>A</sub>)</p>
                        </div>
                        
                        <p><strong>Step 3: Logic Diagram</strong></p>
                        <div class="diagram-description">
                            <p>The circuit consists of three D flip-flops (FF<sub>A</sub>, FF<sub>B</sub>, FF<sub>C</sub>). All share a common clock input. The D inputs are connected according to the derived Boolean expressions:</p>
                            <ul>
                                <li><strong>D<sub>A</sub> = Q<sub>C</sub>' ⋅ Q<sub>B</sub>'</strong> (Requires an AND gate with inputs Q<sub>C</sub>' and Q<sub>B</sub>')</li>
                                <li><strong>D<sub>B</sub> = Q<sub>C</sub>' ⋅ Q<sub>A</sub></strong> (Requires an AND gate with inputs Q<sub>C</sub>' and Q<sub>A</sub>)</li>
                                <li><strong>D<sub>C</sub> = Q<sub>C</sub>' ⋅ Q<sub>B</sub> ⋅ Q<sub>A</sub></strong> (Requires a 3-input AND gate with inputs Q<sub>C</sub>', Q<sub>B</sub>, and Q<sub>A</sub>)</li>
                            </ul>
                            <p>NOT gates will be needed to obtain Q<sub>C</sub>' and Q<sub>B</sub>' from Q<sub>C</sub> and Q<sub>B</sub> respectively.</p>
                            <img src="images/7_mark/Q19_4.png" alt="Logic Diagram of MOD-5 Synchronous Counter using D Flip-Flops">
                        </div>
                        <p>This circuit will cycle through the states 000, 001, 010, 011, 100 and then repeat, effectively counting modulo 5.</p>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>20. Simplify the Boolean function F(W,X,Y,Z) = Σm(...) + d(...) using Quine-McCluskey method.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~1, Example Papers: S2023 (OR))</p>
                    <div class="answer-section">
                        <p>The <strong>Quine-McCluskey method</strong> (also known as the tabulation method) is a tabular algorithm used for systematic minimization of Boolean functions. It is more methodical than K-maps, especially for functions with a larger number of variables (more than 5 or 6), where K-maps become cumbersome. The method guarantees finding all prime implicants and then helps select a minimal set of essential prime implicants to cover the function.</p>
                        
                        <p><strong>Steps Involved:</strong></p>
                        <ol>
                            <li><strong>List Minterms:</strong> List all minterms (for which the function is 1) and any don't care terms in their binary representation. Group them according to the number of 1s they contain.</li>
                            <li><strong>Generate Prime Implicants - Step 1 (Combining terms):</strong>
                                <ul>
                                    <li>Compare each term in a group with 'k' ones against every term in the adjacent group with 'k+1' ones.</li>
                                    <li>If two terms differ by only one bit position, they can be combined. The differing bit is replaced by a dash ('-'), indicating that the variable in that position is eliminated.</li>
                                    <li>Mark (e.g., with a check ✓) the original terms that have been combined.</li>
                                    <li>List the newly formed terms (with one dash) in a new table, again grouped by the number of 1s.</li>
                                </ul>
                            </li>
                            <li><strong>Generate Prime Implicants - Step 2 (Further combinations):</strong>
                                <ul>
                                    <li>Repeat the combination process with the terms generated in the previous step. Combine terms that have dashes in the same position and differ by only one other bit position. The dash remains, and the newly differing bit is also replaced by a dash.</li>
                                    <li>Continue this process until no more terms can be combined.</li>
                                    <li>All unmarked terms (those that could not be combined further) in all tables are the **Prime Implicants (PIs)**.</li>
                                </ul>
                            </li>
                            <li><strong>Create Prime Implicant Chart:</strong>
                                <ul>
                                    <li>Construct a chart with prime implicants listed as rows and the original minterms (for which the function is 1, excluding don't cares for coverage requirement) listed as columns.</li>
                                    <li>Place an 'X' in the chart at the intersection of a PI row and a minterm column if that PI covers that minterm.</li>
                                </ul>
                            </li>
                            <li><strong>Select Essential Prime Implicants (EPIs) and Minimize:</strong>
                                <ul>
                                    <li>Identify **Essential Prime Implicants (EPIs)**: A PI is essential if it is the only PI that covers one or more minterms (i.e., a column has only one 'X'). Select all EPIs.</li>
                                    <li>Mark the minterms covered by the selected EPIs.</li>
                                    <li>If all minterms are covered, the sum of EPIs is the minimized function.</li>
                                    <li>If some minterms remain uncovered, select additional PIs (non-essential ones) that cover the remaining minterms with minimal overlap or cost, often using techniques like Petrick's method or by inspection for simpler cases.</li>
                                </ul>
                            </li>
                        </ol>

                        <p><strong>Example: Simplify F(W,X,Y,Z) = Σm(0, 1, 2, 5, 7, 8, 10, 13, 15) + d(3, 14)</strong></p>
                        <p><em>(Note: A full Quine-McCluskey tabulation for a 4-variable function with don't cares is extensive and best shown in a tabular format that is hard to replicate perfectly here. The following is a conceptual outline of the process and expected outcome for this specific example.)</em></p>
                        <p><strong>1. Initial Grouping of Minterms and Don't Cares by Number of 1s:</strong></p>
                        <div class="code-block">
Group 0 (0 ones): m0(0000)
Group 1 (1 one):  m1(0001), m2(0010), m8(1000), d4(0100)
Group 2 (2 ones): d3(0011), m5(0101), m10(1010), d6(0110), d12(1100)
Group 3 (3 ones): m7(0111), m13(1101), d14(1110), m11(1011) 
Group 4 (4 ones): m15(1111)
                        </div>
                        <p><strong>2. Combining Terms (Pass 1 - producing terms with one dash):</strong></p>
                        <p>Systematically compare terms between adjacent groups. For example:</p>
                        <ul>
                            <li>(m0,m1) → 000-</li>
                            <li>(m0,m2) → 00-0</li>
                            <li>(m0,m8) → -000</li>
                            <li>(m1,d3) → 00-1 (using d3)</li>
                            <li>(m1,m5) → 0-01</li>
                            <li>... and so on for all possible combinations. Mark combined terms.</li>
                        </ul>
                        <p><strong>3. Combining Terms (Pass 2 - producing terms with two dashes):</strong></p>
                        <p>Combine terms from Pass 1 that have dashes in the same position and differ by one bit. For example:</p>
                        <ul>
                            <li>(000-, 001-) → 00-- (if (m0,m1) and (m2,d3) combined)</li>
                            <li>... and so on. Mark combined terms.</li>
                        </ul>
                        <p><strong>4. Identify Prime Implicants:</strong> All terms that cannot be combined further are the prime implicants.</p>
                        <p>For F(W,X,Y,Z) = Σm(0,1,2,5,7,8,10,13,15) + d(3,14), the prime implicants after full tabulation would likely be (this is an illustrative set, actual PIs depend on the rigorous process):</p>
                        <ul>
                            <li>PI<sub>1</sub> = W'Y' (covers m0, m1, d2, d3 from 0-0-)</li>
                            <li>PI<sub>2</sub> = XZ (covers m5, m7, m13, m15 from -1-1)</li>
                            <li>PI<sub>3</sub> = WX'Z' (covers m8, m10 from 10-0)</li>
                            <li>PI<sub>4</sub> = WY'Z (covers m13, m15 from 1-01 - this might be redundant or part of XZ)</li>
                            <li>PI<sub>5</sub> = WXZ' (covers m10, d14 from 1-10)</li>
                        </ul>
                        <p>A more accurate set of PIs for this function, after full tabulation, is typically: XZ, W'Y', WX'Z', WXY' (or WXD').</p>

                        <p><strong>5. Prime Implicant Chart:</strong></p>
                        <p>(Rows are PIs, Columns are original minterms of F: 0,1,2,5,7,8,10,13,15. Don't cares are NOT listed as columns to be covered.)</p>
                        <div class="diagram-description">
                            <p>A table would be drawn here with the actual PIs down the side and minterms across the top, with 'X's marking which PIs cover which minterms.</p>
                            <img src="https://placehold.co/600x300/e2e8f0/4a5568?text=Prime+Implicant+Chart" alt="Prime Implicant Chart">
                        </div>

                        <p><strong>6. Select EPIs and other PIs for minimal cover:</strong></p>
                        <ul>
                            <li>Identify EPIs by finding columns with a single 'X'.</li>
                            <li>Select EPIs and mark the minterms they cover.</li>
                            <li>If minterms remain, select other PIs to cover them.</li>
                        </ul>
                        <p>For F(W,X,Y,Z) = Σm(0,1,2,5,7,8,10,13,15) + d(3,14), the minimized expression after applying the Quine-McCluskey procedure correctly is generally found to be: <strong>F = XZ + W'Y' + WX'Z'</strong>.</p>
                        <p><strong>Key elements for a 7-mark answer:</strong> A clear explanation of the Quine-McCluskey method's steps: grouping minterms, systematically combining terms to find all prime implicants, constructing a prime implicant chart, and selecting essential (and other necessary) prime implicants to form the minimized SOP expression. While a full Q-M for a 4-variable function with don't cares is lengthy for an exam answer, demonstrating understanding of the process with key stages of an example is expected. Showing the initial grouping and at least one or two combination steps, followed by the structure of the PI chart and the selection logic, would be important.</p>
                    </div>
                </div>
            </details>
            
        </section>
        <section id="3markAnswers" style="display:none;"> <h2>3-Mark Question Themes</h2>
             <p class="text-center text-gray-500 p-8">Detailed answers for 3-mark questions will be added here.</p>
        </section>
    </div>

    <script>
        // Script to make answers collapsible
        document.addEventListener('DOMContentLoaded', () => {
            const detailsElements = document.querySelectorAll('details.qa-block');
            detailsElements.forEach(detail => {
                // Optional: If you want only one open at a time, uncomment below
                // detail.addEventListener('toggle', event => {
                //     if (detail.open) {
                //         detailsElements.forEach(otherDetail => {
                //             if (otherDetail !== detail) {
                //                 otherDetail.removeAttribute('open');
                //             }
                //         });
                //     }
                // });
            });
            console.log("7-Mark Q&A Page Loaded with collapsible answers.");
        });
    </script>
</body>
</html>
