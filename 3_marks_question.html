<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Fundamentals - Detailed 3-Mark Q&A</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #fdfaf6; color: #333; line-height: 1.7; }
        .container { max-width: 900px; margin-left: auto; margin-right: auto; padding: 1rem 2rem 2rem 2rem; }
        header h1 { color: #1e3a8a; font-size: 2.25rem; font-weight: 700; margin-bottom: 0.5rem; text-align: center; }
        header p.subtitle {text-align: center; color: #4b5563; margin-bottom: 2rem; font-size:0.9rem;}
        h2 { color: #1d4ed8; font-size: 1.75rem; font-weight:600; margin-top: 2.5rem; margin-bottom:1.5rem; border-bottom: 2px solid #3b82f6; padding-bottom: 0.5rem;}
        
        details.qa-block {
            background-color: white; 
            border-radius: 0.5rem; 
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06); 
            margin-bottom: 1.5rem; 
            border-left: 5px solid #16a34a; /* Green for 3-mark */
            overflow: hidden; 
        }
        details.qa-block summary {
            padding: 1.25rem 1.5rem;
            cursor: pointer;
            font-size: 1.15rem; /* Slightly smaller for 3-mark */
            font-weight: 600;
            color: #14532d; /* Darker Green for 3-mark questions */
            list-style: none; 
            position: relative;
            outline: none;
        }
        details.qa-block summary::-webkit-details-marker { display: none; } 
        details.qa-block summary::before { 
            content: '▼';
            position: absolute;
            left: 0.5rem;
            top: 50%;
            transform: translateY(-50%) rotate(0deg);
            font-size: 0.8em;
            color: #16a34a;
            transition: transform 0.2s ease-in-out;
        }
        details.qa-block[open] summary::before {
            transform: translateY(-50%) rotate(180deg);
        }
        .answer-container {
            padding: 0 1.5rem 1.5rem 1.5rem; 
        }
        .citation-info { font-size: 0.8rem; color: #6b7280; display: block; margin-top: 0.25rem; margin-bottom: 1rem; font-style: italic;}
        .answer-section p, .answer-section ul, .answer-section ol { margin-bottom: 1rem; font-size:0.95rem; }
        .answer-section ul { list-style-type: disc; margin-left: 1.75rem; }
        .answer-section ol { list-style-type: decimal; margin-left: 1.75rem; }
        .answer-section strong { color: #172554; font-weight: 600;}
        .answer-section table { width: auto; min-width: 60%; margin-top:0.75rem; margin-bottom: 1rem; border-collapse: collapse; font-size: 0.9rem; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .answer-section th, .answer-section td { border: 1px solid #d1d5db; padding: 0.6rem 0.85rem; text-align: center; vertical-align: middle; }
        .answer-section th { background-color: #dcfce7; font-weight: 600; color: #14532d;} 
        .answer-section td:first-child {text-align: left;} 
        .answer-section .code-block { background-color: #f8fafc; border: 1px solid #e2e8f0; padding: 1rem; border-radius: 0.375rem; font-family: 'Courier New', Courier, monospace; white-space: pre-wrap; margin-bottom: 1rem; font-size: 0.9rem; overflow-x: auto; line-height: 1.5;}
        .answer-section .diagram-description { background-color: #ecfdf5; border: 1px dashed #a7f3d0; border-left: 4px solid #059669; padding: 1rem; margin-top: 0.75rem; margin-bottom: 1rem; font-style: italic; color: #047857; border-radius: 0.25rem;}
        .answer-section img { max-width: 100%; height: auto; margin-top: 0.5rem; margin-bottom: 0.5rem; border: 1px solid #e5e7eb; border-radius: 0.25rem; display: block; margin-left:auto; margin-right:auto; }
        .back-link-container { margin-bottom: 2rem; text-align: center;}
        .back-link { display: inline-block; padding: 0.6rem 1.2rem; background-color: #3b82f6; color: white; border-radius: 0.375rem; text-decoration: none; transition: background-color 0.3s ease; font-weight: 500;}
        .back-link:hover { background-color: #2563eb; }
        hr.section-divider { border: none; height: 1px; background-color: #d1d5db; margin: 2rem 0; }
    </style>
</head>
<body class="antialiased">
    <div class="container">
        <header>
            <h1>Digital Fundamentals - Detailed Q&A</h1>
            <p class="subtitle">Comprehensive Answers for 3-Mark Question Themes</p>
            <div class="back-link-container">
                <a href="index.html" class="back-link">&larr; Back to Main Analyzer Page</a>
                </div>
        </header>
        
        <section id="3markAnswersContainer">
            <h2>3-Mark Question Themes</h2>
            <p class="text-center text-gray-600 mb-8 text-sm">Detailed explanations for frequently encountered 3-mark question themes. Illustrative frequencies and example paper mentions (S=Summer, W=Winter) are based on analysis of the provided syllabus and past papers.</p>

            <details class="qa-block">
                <summary>1. List out various logic families. Also list characteristics of digital IC.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~3, Example Papers: S2024, W2023, S2022)</p>
                    <div class="answer-section">
                        <p><strong>Various Logic Families:</strong></p>
                        <p>Logic families are collections of integrated circuits (ICs) that share common electrical characteristics such as logic levels, power supply voltages, and input/output structures, allowing them to be interconnected directly. Key logic families include:</p>
                        <ul>
                            <li><strong>RTL (Resistor-Transistor Logic):</strong> One of the earliest families, using resistors at inputs and BJTs as switching elements. (Largely historical)</li>
                            <li><strong>DTL (Diode-Transistor Logic):</strong> Used diodes for input logic and BJTs for amplification. An improvement over RTL. (Largely historical)</li>
                            <li><strong>TTL (Transistor-Transistor Logic):</strong> A widely used family based on BJTs, known for its speed and drive capability. It has several sub-families like Standard TTL (74xx), Low-power Schottky (74LSxx), Schottky (74Sxx), Advanced Schottky (74ASxx), and Fast (74Fxx).</li>
                            <li><strong>ECL (Emitter-Coupled Logic):</strong> The fastest logic family, using BJTs in a differential amplifier configuration, preventing transistors from saturating. Characterized by high power consumption.</li>
                            <li><strong>MOS Logic (Metal-Oxide-Semiconductor):</strong> Uses MOSFETs as switching elements.
                                <ul>
                                    <li><strong>PMOS Logic:</strong> Uses P-channel MOSFETs. (Historical)</li>
                                    <li><strong>NMOS Logic:</strong> Uses N-channel MOSFETs. Offered better performance and density than PMOS. (Historical)</li>
                                </ul>
                            </li>
                            <li><strong>CMOS (Complementary MOS):</strong> Uses both PMOS and NMOS transistors in a complementary arrangement. It is the dominant logic family today due to its very low static power dissipation, high noise immunity, and wide operating voltage range. Common series include 4000 series, 74HCxx (High-speed CMOS), 74HCTxx (TTL-compatible CMOS), 74ACxx (Advanced CMOS), etc.</li>
                            <li><strong>BiCMOS (Bipolar-CMOS):</strong> Combines BJT technology (for speed and drive capability) with CMOS technology (for low power and high density) on the same chip.</li>
                        </ul>
                        <hr class="section-divider"/>
                        <p><strong>Characteristics of Digital ICs:</strong></p>
                        <p>Key parameters used to characterize digital ICs include:</p>
                        <ol>
                            <li><strong>Propagation Delay (t<sub>p</sub>):</strong> The time taken for a signal change at the input of a gate to produce a change in its output. It determines the maximum operating speed of the IC. (e.g., t<sub>pLH</sub>, t<sub>pHL</sub>).</li>
                            <li><strong>Power Dissipation (P<sub>D</sub>):</strong> The amount of power consumed by the IC. This includes static ( quiescent) and dynamic (switching) power. Lower power dissipation is desirable for efficiency and thermal management.</li>
                            <li><strong>Noise Margin (NM):</strong> The maximum noise voltage that can be tolerated at the input of a gate without causing an incorrect output. It indicates the circuit's immunity to noise. (NM<sub>H</sub> and NM<sub>L</sub>).</li>
                            <li><strong>Fan-in:</strong> The number of inputs that a single logic gate can accept.</li>
                            <li><strong>Fan-out:</strong> The maximum number of standard inputs of gates from the same logic family that the output of a single gate can reliably drive.</li>
                            <li><strong>Figure of Merit (Speed-Power Product):</strong> The product of propagation delay and power dissipation (t<sub>p</sub> × P<sub>D</sub>). A lower value indicates a better overall performance trade-off.</li>
                            <li><strong>Operating Supply Voltage:</strong> The range of supply voltages (V<sub>CC</sub> or V<sub>DD</sub>) over which the IC is designed to operate correctly.</li>
                            <li><strong>Logic Levels:</strong> The voltage ranges that define logic '0' (LOW) and logic '1' (HIGH) for both the inputs (V<sub>IL</sub> - max input low, V<sub>IH</sub> - min input high) and outputs (V<sub>OL</sub> - max output low, V<sub>OH</sub> - min output high) of the gates.</li>
                        </ol>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>2. What is race around condition in JK flip flop?</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~4, Example Papers: W2024, S2024 (OR), W2021, W2019 (OR))</p>
                    <div class="answer-section">
                        <p>The **race-around condition** is an undesirable phenomenon that can occur in **level-triggered JK flip-flops** (as opposed to edge-triggered ones). It specifically happens when both the J and K inputs are held HIGH (logic 1) simultaneously – the condition under which the flip-flop is supposed to toggle its output state.</p>
                        <p><strong>Explanation of the Condition:</strong></p>
                        <ol>
                            <li>In a level-triggered JK flip-flop, the outputs are sensitive to the inputs as long as the clock input is at its active level (e.g., when CLK is HIGH).</li>
                            <li>When J=1 and K=1, the JK flip-flop is instructed to toggle. So, if the current output Q is 0, it will change to 1. If Q is 1, it will change to 0.</li>
                            <li>The problem arises if the clock pulse remains at its active level for a duration longer than the propagation delay of the flip-flop (the time it takes for the output to change after the inputs have changed and the clock is active).</li>
                            <li>Once the output Q toggles (e.g., from 0 to 1), this new output value (Q=1, Q'=0) is immediately fed back to the internal gating circuitry of the flip-flop.</li>
                            <li>Since J and K are still HIGH and the clock is still at its active level, the flip-flop sees the conditions to toggle *again*. So, Q might toggle back (e.g., from 1 to 0).</li>
                            <li>This unwanted multiple toggling (0 → 1 → 0 → 1 → ...) can continue repeatedly as long as the clock pulse remains active and its duration (pulse width) is greater than the flip-flop's propagation delay. The output "races" between the two logic states.</li>
                        </ol>
                        <p>The final state of the flip-flop when the clock pulse eventually goes to its inactive level becomes unpredictable and unreliable, as it depends on how many times the output toggled during the active clock period. This makes the circuit's behavior indeterminate under these specific conditions.</p>
                        <p><strong>Conditions Leading to Race-Around:</strong></p>
                        <ul>
                            <li>The flip-flop must be **level-triggered**.</li>
                            <li>Both inputs J and K must be held at logic 1.</li>
                            <li>The duration of the active clock pulse (t<sub>pulse_width</sub>) must be greater than the propagation delay (t<sub>pd</sub>) of the flip-flop.</li>
                        </ul>
                        <p><strong>Avoidance:</strong> The race-around condition is typically avoided by using **edge-triggered JK flip-flops** or **Master-Slave JK flip-flops**, which ensure that the output changes only once per clock cycle based on the input conditions at the triggering clock edge.</p>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>3. Compare static RAM and dynamic RAM.</summary>
                <div class="answer-container">
                     <p class="citation-info">(Illustrative Frequency: ~3, Example Papers: S2024, W2024, W2023)</p>
                    <div class="answer-section">
                        <p>Static RAM (SRAM) and Dynamic RAM (DRAM) are both types of volatile semiconductor Random Access Memory (RAM), meaning they require continuous power to retain stored data. However, they differ significantly in their underlying technology, cell structure, performance characteristics, and typical applications.</p>
                        <table>
                            <thead>
                                <tr><th>Feature / Parameter</th><th>Static RAM (SRAM)</th><th>Dynamic RAM (DRAM)</th></tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>1. Storage Cell Structure</strong></td>
                                    <td>Uses flip-flops (typically constructed from 4 to 6 transistors) to store each bit. Data is held as long as power is supplied.</td>
                                    <td>Uses a single transistor and a capacitor to store each bit. Data is stored as an electrical charge on the capacitor.</td>
                                </tr>
                                <tr>
                                    <td><strong>2. Data Retention</strong></td>
                                    <td>Holds data as long as power is on; no periodic refreshing is needed. "Static" refers to this stability.</td>
                                    <td>Data is stored as charge on a capacitor which gradually leaks away. Therefore, DRAM cells must be periodically refreshed (read and rewritten) to retain data, typically every few milliseconds. "Dynamic" refers to this need for refreshing.</td>
                                </tr>
                                <tr>
                                    <td><strong>3. Cell Complexity & Size</strong></td>
                                    <td>More complex cell structure due to multiple transistors per bit, resulting in a larger cell size on the silicon die.</td>
                                    <td>Simpler and smaller cell structure (one transistor, one capacitor per bit), allowing for significantly higher packing density.</td>
                                </tr>
                                <tr>
                                    <td><strong>4. Density</strong></td>
                                    <td>Lower packing density. Fewer bits can be stored per unit area of silicon.</td>
                                    <td>Higher packing density. Significantly more bits can be stored on a chip of the same size, leading to larger capacity memory chips.</td>
                                </tr>
                                <tr>
                                    <td><strong>5. Speed (Access Time)</strong></td>
                                    <td>Generally faster access times (e.g., typically ranging from less than 1 ns to a few tens of nanoseconds). No refresh cycles means data is always immediately available for read/write.</td>
                                    <td>Generally slower access times compared to SRAM (e.g., typically ranging from a few tens to over a hundred nanoseconds for initial access, though techniques like burst mode and SDRAM improve throughput for sequential access). Refresh cycles also introduce latency.</td>
                                </tr>
                                <tr>
                                    <td><strong>6. Cost per Bit</strong></td>
                                    <td>Higher cost per bit due to lower density and more complex manufacturing process for the larger cells.</td>
                                    <td>Lower cost per bit due to higher density and simpler cell structure, making it more economical for large memory systems.</td>
                                </tr>
                                <tr>
                                    <td><strong>7. Power Consumption</strong></td>
                                    <td>Higher static power consumption because the flip-flops continuously draw some current to maintain their state (though modern SRAMs have low-power standby modes). Dynamic power is also consumed during access.</td>
                                    <td>Lower static power consumption (mainly due to leakage from capacitors and the refresh circuitry when idle). However, dynamic power consumption during read/write operations and especially during refresh cycles can be significant.</td>
                                </tr>
                                <tr>
                                    <td><strong>8. Refresh Circuitry</strong></td>
                                    <td>Not required.</td>
                                    <td>Requires external or on-chip refresh circuitry and control logic to periodically recharge the capacitors, adding complexity to the memory system design and control.</td>
                                </tr>
                                <tr>
                                    <td><strong>9. Typical Applications</strong></td>
                                    <td>Cache memory (L1, L2, L3 caches in CPUs and microcontrollers), register files, high-speed buffers, and specific application memories where very fast access times are critical and capacity is smaller.</td>
                                    <td>Main system memory (RAM) in personal computers, servers, and workstations; graphics memory (GDDR); memory in mobile devices, and other applications where large memory capacity at a lower cost is the primary concern.</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>4. Reduce a given Boolean expression (e.g., F=x'y'z+yz+xz).</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~2, Example Papers: S2024, W2023)</p>
                    <div class="answer-section">
                        <p>To reduce a Boolean expression, we can use Boolean algebra postulates, theorems, and techniques like Karnaugh maps (K-maps) or the Quine-McCluskey method. For a 3-variable expression, Boolean algebra or a K-map is usually sufficient.</p>
                        <p><strong>Given Expression: F = x'y'z + yz + xz</strong></p>
                        
                        <p><strong>Method 1: Using Boolean Algebra</strong></p>
                        <ol>
                            <li>Start with the given expression:
                                <br/>F = x'y'z + yz + xz
                            </li>
                            <li>Factor out 'z' from all terms (Distributive Law: AB + AC = A(B+C)):
                                <br/>F = z (x'y' + y + x)
                            </li>
                            <li>Focus on the term (x'y' + y + x). We can use the absorption law or distributive law.
                                <br/>Consider y + x'y': This is equivalent to y + x' (using A + A'B = A+B, where A=y, B=x').
                                <br/>So, (x'y' + y + x) becomes (y + x' + x).
                            </li>
                            <li>Since x' + x = 1 (Complement Law).</li>
                            <li>Therefore, (y + x' + x) = (y + 1).</li>
                            <li>And y + 1 = 1 (Annulment Law).</li>
                            <li>So, F = z (1)</li>
                            <li><strong>F = z</strong></li>
                        </ol>
                        
                        <p><strong>Method 2: Using K-Map (for 3 variables x, y, z)</strong></p>
                        <p>First, identify the minterms for each product term:</p>
                        <ul>
                            <li>x'y'z corresponds to binary 001, which is minterm m<sub>1</sub>.</li>
                            <li>yz: This term is missing 'x'. So it represents both x'yz (011 → m<sub>3</sub>) and xyz (111 → m<sub>7</sub>).</li>
                            <li>xz: This term is missing 'y'. So it represents xy'z (101 → m<sub>5</sub>) and xyz (111 → m<sub>7</sub>). (m<sub>7</sub> is already included from the previous term).</li>
                        </ul>
                        <p>So, the function in terms of minterms is F(x,y,z) = Σm(1, 3, 5, 7).</p>
                        <p>Now, draw the K-map for 3 variables (let x be the row variable, yz be the column variables):</p>
                        <div class="code-block">
  yz\x | 0 (x')| 1 (x) |
  -----|-------|-------|
   00  |   0   |   0   | (m0, m4)
   01  |   1   |   1   | (m1, m5)
   11  |   1   |   1   | (m3, m7)
   10  |   0   |   0   | (m2, m6)
                        </div>
                        <p><strong>Grouping the 1s:</strong></p>
                        <p>We can form a single large group (a quad) of four 1s covering minterms m1, m3, m5, and m7.
                        This group corresponds to the cells where:</p>
                        <ul>
                            <li>x changes from 0 to 1 (so x is eliminated).</li>
                            <li>y changes from 0 to 1 (so y is eliminated).</li>
                            <li>z is always 1 (so z remains).</li>
                        </ul>
                        <p>Thus, the simplified expression from the K-map is <strong>F = z</strong>.</p>
                        <div class="diagram-description">
                            <p><strong>K-Map Visualization:</strong></p>
                            <img src="images/3_mark/Q4.png" alt="K-Map for F=x'y'z+yz+xz">
                            <p>The K-map would visually show the four 1s forming a column, which simplifies to the variable 'z'.</p>
                        </div>
                        <p>Both methods (Boolean algebra and K-map) yield the same simplified result: F = z.</p>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>5. Explain SR flip-flop using characteristic table & characteristic equation.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~2, Example Papers: W2022, W2019)</p>
                    <div class="answer-section">
                        <p>The **SR (Set-Reset) flip-flop** is a basic bistable multivibrator, meaning it has two stable states and can store one bit of information. It has two inputs: S (Set) and R (Reset), and typically two outputs: Q (the normal output) and Q' (the complemented output). The SR flip-flop can be level-triggered (asynchronous, often called an SR latch) or clocked (synchronous).</p>
                        <p><strong>Operation (assuming a clocked SR flip-flop):</strong></p>
                        <ul>
                            <li><strong>S=0, R=0 (No Change / Hold State):</strong> If both S and R are LOW (logic 0) when the clock pulse is active, the flip-flop's output Q remains in its previous state. The stored bit is unchanged (Q<sub>n+1</sub> = Q<sub>n</sub>).</li>
                            <li><strong>S=0, R=1 (Reset State):</strong> If S is LOW and R is HIGH, the flip-flop is reset on the active clock edge. Q output goes to 0.</li>
                            <li><strong>S=1, R=0 (Set State):</strong> If S is HIGH and R is LOW, the flip-flop is set on the active clock edge. Q output goes to 1.</li>
                            <li><strong>S=1, R=1 (Forbidden / Invalid State):</strong> This input condition is generally considered invalid or forbidden because it leads to an unpredictable or undesirable state where both Q and Q' might try to go to the same logic level (e.g., both LOW for NAND-based SR latch, or both HIGH for NOR-based SR latch), violating the Q = Q' relationship. In clocked versions, it can lead to a race condition or an unpredictable next state. Therefore, this input combination is usually avoided in circuit design.</li>
                        </ul>
                        
                        <p><strong>Characteristic Table (for a clocked SR Flip-Flop):</strong></p>
                        <p>Defines the next state (Q<sub>n+1</sub>) based on current inputs (S, R) and current state (Q<sub>n</sub>) at the active clock edge.</p>
                        <table>
                            <thead>
                                <tr><th>S</th><th>R</th><th>Q<sub>n</sub></th><th>Q<sub>n+1</sub></th><th>Operation</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>No Change (Hold)</td></tr>
                                <tr><td>0</td><td>0</td><td>1</td><td>1</td><td>No Change (Hold)</td></tr>
                                <tr><td>0</td><td>1</td><td>0</td><td>0</td><td>Reset</td></tr>
                                <tr><td>0</td><td>1</td><td>1</td><td>0</td><td>Reset</td></tr>
                                <tr><td>1</td><td>0</td><td>0</td><td>1</td><td>Set</td></tr>
                                <tr><td>1</td><td>0</td><td>1</td><td>1</td><td>Set</td></tr>
                                <tr><td>1</td><td>1</td><td>0</td><td>X (or Indeterminate)</td><td>Forbidden / Invalid</td></tr>
                                <tr><td>1</td><td>1</td><td>1</td><td>X (or Indeterminate)</td><td>Forbidden / Invalid</td></tr>
                            </tbody>
                        </table>
                        <p><em>(X indicates an invalid or indeterminate state for Q<sub>n+1</sub> when S=R=1).</em></p>

                        <p><strong>Characteristic Equation:</strong></p>
                        <p>Assuming the S=R=1 condition is avoided (i.e., S⋅R = 0 is always true), the characteristic equation can be derived from the K-map or truth table:</p>
                        <p><strong>Q<sub>n+1</sub> = S + R'Q<sub>n</sub></strong> (This equation is valid under the constraint S⋅R = 0).</p>
                        <p>If the S=R=1 case is considered and leads to Q=Q'=0 (for NOR latch based) or Q=Q'=1 (for NAND latch based), the equation becomes more complex or is usually handled by ensuring the forbidden state is not entered.</p>
                        <div class="diagram-description">
                            <p><strong>Logic Diagram (Conceptual Block):</strong> The standard symbol for a clocked SR flip-flop is a rectangle with input lines for S, R, and CLK (the clock input often has a small triangle to indicate it's edge-triggered). It has output lines Q and Q'.</p>
                            <img src="images/3_mark/Q5.png" alt="Block diagram of an SR Flip-Flop">
                        </div>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>6. Explain the specification of D/A converter.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~2, Example Papers: S2024 (OR), W2019)</p>
                    <div class="answer-section">
                        <p>The specifications of a Digital-to-Analog Converter (DAC) define its performance and characteristics. Key specifications include:</p>
                        <ol>
                            <li>
                                <p><strong>Resolution:</strong></p>
                                <ul>
                                    <li><strong>Definition:</strong> The smallest change in analog output voltage that can be produced by the DAC, corresponding to a change of one Least Significant Bit (LSB) in the digital input. It is determined by the number of input bits (n).</li>
                                    <li><strong>Formula:</strong> Resolution = V<sub>FS</sub> / (2<sup>n</sup> - 1) or V<sub>FS</sub> / 2<sup>n</sup>, where V<sub>FS</sub> is the full-scale output voltage. Often, it's also expressed as the value of 1 LSB: 1 LSB = V<sub>ref</sub> / 2<sup>n</sup>.</li>
                                    <li><strong>Significance:</strong> Higher resolution (more bits) means smaller step sizes and a finer, more accurate analog output.</li>
                                </ul>
                            </li>
                            <li>
                                <p><strong>Accuracy:</strong></p>
                                <ul>
                                    <li><strong>Definition:</strong> A measure of how close the actual analog output is to the ideal or theoretical output value for a given digital input. It's often expressed as a percentage of the full-scale voltage or in terms of LSBs (e.g., ±1/2 LSB).</li>
                                    <li><strong>Factors:</strong> Affected by linearity, offset error, gain error, and resistor precision.</li>
                                </ul>
                            </li>
                            <li>
                                <p><strong>Linearity:</strong></p>
                                <ul>
                                    <li><strong>Definition:</strong> Measures the deviation of the actual DAC output from an ideal straight-line transfer characteristic. If the output steps are all equal in size, the DAC is perfectly linear.</li>
                                    <li><strong>Types:</strong>
                                        <ul>
                                            <li><strong>Differential Linearity Error (DNL):</strong> The maximum deviation in the step size between adjacent digital codes from the ideal 1 LSB step. DNL < ±1 LSB ensures monotonicity.</li>
                                            <li><strong>Integral Linearity Error (INL):</strong> The maximum deviation of the actual transfer function from an ideal straight line drawn between the zero and full-scale points.</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <p><strong>Monotonicity:</strong></p>
                                <ul>
                                    <li><strong>Definition:</strong> A DAC is monotonic if its analog output always increases or stays the same for an increasing digital input code (and vice-versa). It never decreases for an increasing input.</li>
                                    <li><strong>Significance:</strong> Crucial for control applications. Guaranteed if DNL ≤ ±1 LSB.</li>
                                </ul>
                            </li>
                            <li>
                                <p><strong>Settling Time (t<sub>s</sub>):</strong></p>
                                <ul>
                                    <li><strong>Definition:</strong> The time taken for the DAC output to settle within a specified error band (e.g., ±1/2 LSB or ±0.01% of its final value) of its final value after a change in the digital input code (typically a full-scale change).</li>
                                    <li><strong>Significance:</strong> Determines the maximum conversion rate or speed of the DAC.</li>
                                </ul>
                            </li>
                            <li>
                                <p><strong>Full-Scale Output Voltage (V<sub>FS</sub>):</strong></p>
                                <ul>
                                    <li><strong>Definition:</strong> The analog output voltage when all digital input bits are HIGH (1). It's usually slightly less than the reference voltage (e.g., V<sub>ref</sub>(1 - 1/2<sup>n</sup>)).</li>
                                </ul>
                            </li>
                        </ol>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>7. Define Minterm and Maxterm.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~1, Example Papers: S2022 (OR))</p>
                    <div class="answer-section">
                        <p>Minterms and Maxterms are fundamental concepts in Boolean algebra used to express Boolean functions in standard or canonical forms. They provide a unique way to represent a function based on its truth table for a given set of 'n' variables.</p>
                        
                        <p><strong>Minterm (Product Term):</strong></p>
                        <ul>
                            <li><strong>Definition:</strong> A minterm of 'n' Boolean variables is a **product term (logical AND)** in which each of the 'n' variables appears exactly once, either in its true (uncomplemented) form or its complemented (negated) form.</li>
                            <li><strong>Property:</strong> Each minterm evaluates to logic '1' for only one unique combination of the input variable values and is '0' for all other 2<sup>n</sup>-1 combinations.</li>
                            <li><strong>Notation:</strong> Minterms are often denoted by m<sub>i</sub>, where the subscript 'i' is the decimal equivalent of the binary input combination for which that particular minterm is '1'.
                                <ul>
                                    <li>A variable appears <strong>complemented</strong> (e.g., A') in the minterm if its value is <strong>0</strong> in the binary combination that results in the minterm being 1.</li>
                                    <li>A variable appears <strong>uncomplemented</strong> (e.g., A) in the minterm if its value is <strong>1</strong> in that binary combination.</li>
                                </ul>
                            </li>
                            <li><strong>Example (for 3 variables A, B, C):</strong>
                                <ul>
                                    <li>If the input combination is ABC = 000 (decimal 0), the corresponding minterm is m<sub>0</sub> = A'B'C'. (This term is 1 only when A=0, B=0, C=0).</li>
                                    <li>If the input combination is ABC = 011 (decimal 3), the corresponding minterm is m<sub>3</sub> = A'BC. (This term is 1 only when A=0, B=1, C=1).</li>
                                </ul>
                            </li>
                            <li><strong>Canonical Sum of Products (SOP):</strong> Any Boolean function can be expressed as a logical sum (ORing) of all the minterms for which the function's output is '1'. This is called the canonical SOP form or minterm expansion. For instance, if F(A,B,C) is 1 for minterms m1, m3, and m5, then F = m1 + m3 + m5 = A'B'C + A'BC + AB'C.</li>
                        </ul>
                        
                        <hr class="section-divider"/>

                        <p><strong>Maxterm (Sum Term):</strong></p>
                        <ul>
                            <li><strong>Definition:</strong> A maxterm of 'n' Boolean variables is a **sum term (logical OR)** in which each of the 'n' variables appears exactly once, either in its true (uncomplemented) form or its complemented (negated) form.</li>
                            <li><strong>Property:</strong> Each maxterm evaluates to logic '0' for only one unique combination of the input variable values and is '1' for all other 2<sup>n</sup>-1 combinations.</li>
                            <li><strong>Notation:</strong> Maxterms are often denoted by M<sub>i</sub>, where the subscript 'i' is the decimal equivalent of the binary input combination for which that particular maxterm is '0'.
                                <ul>
                                    <li>A variable appears <strong>uncomplemented</strong> (e.g., A) in the maxterm if its value is <strong>0</strong> in the binary combination that results in the maxterm being 0.</li>
                                    <li>A variable appears <strong>complemented</strong> (e.g., A') in the maxterm if its value is <strong>1</strong> in that binary combination. (Note: This is opposite to how variables appear in minterms for the same index 'i').</li>
                                </ul>
                            </li>
                            <li><strong>Example (for 3 variables A, B, C):</strong>
                                <ul>
                                    <li>If the input combination is ABC = 000 (decimal 0), the corresponding maxterm is M<sub>0</sub> = A+B+C. (This term is 0 only when A=0, B=0, C=0).</li>
                                    <li>If the input combination is ABC = 011 (decimal 3), the corresponding maxterm is M<sub>3</sub> = A+B'+C'. (This term is 0 only when A=0, B=1, C=1).</li>
                                </ul>
                            </li>
                            <li><strong>Canonical Product of Sums (POS):</strong> Any Boolean function can be expressed as a logical product (ANDing) of all the maxterms for which the function's output is '0'. This is called the canonical POS form or maxterm expansion. For example, if F(A,B,C) is 0 for input combinations corresponding to M0, M2, and M4, then F = M0 ⋅ M2 ⋅ M4 = (A+B+C) ⋅ (A+B'+C) ⋅ (A'+B+C).</li>
                        </ul>
                        <p>It's important to note that a minterm m<sub>i</sub> and a maxterm M<sub>i</sub> with the same index are complements of each other: m<sub>i</sub>' = M<sub>i</sub> and M<sub>i</sub>' = m<sub>i</sub>.</p>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>8. What are universal gates? Name them.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~3, Example Papers: S2023, W2022, S2021)</p>
                    <div class="answer-section">
                        <p><strong>Universal Gates:</strong></p>
                        <p>In digital logic, a **universal gate** is a type of logic gate that can be used, by itself or in combination with only other gates of the same type, to implement any other type of basic logic gate (AND, OR, NOT) or any arbitrary Boolean function. The ability to construct all fundamental logic operations using only a specific type of gate makes that gate "universal."</p>
                        <p>The primary universal gates are:</p>
                        <ol>
                            <li><strong>NAND Gate:</strong>
                                <ul>
                                    <li>A NAND gate (which stands for NOT-AND) produces an output that is FALSE (logic 0) only if all of its inputs are TRUE (logic 1). Otherwise, its output is TRUE (logic 1).</li>
                                    <li>It is considered universal because the three basic logic functions (NOT, AND, OR) can be implemented using only NAND gates:
                                        <ul>
                                            <li><strong>NOT from NAND:</strong> Connect all inputs of a NAND gate together (or tie unused inputs to logic 1). If input is A, output is (A⋅A)' = A'.</li>
                                            <li><strong>AND from NAND:</strong> A NAND gate followed by a NAND gate configured as a NOT gate. (A⋅B)'' = A⋅B.</li>
                                            <li><strong>OR from NAND:</strong> Using De Morgan's theorem, A+B = (A'⋅B')'. This requires inverting the inputs first (using NANDs as NOTs) and then NANDing the results.</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li><strong>NOR Gate:</strong>
                                <ul>
                                    <li>A NOR gate (which stands for NOT-OR) produces an output that is TRUE (logic 1) only if all of its inputs are FALSE (logic 0). Otherwise, its output is FALSE (logic 0).</li>
                                    <li>It is also universal because the three basic logic functions can be implemented using only NOR gates:
                                        <ul>
                                            <li><strong>NOT from NOR:</strong> Connect all inputs of a NOR gate together (or tie unused inputs to logic 0). If input is A, output is (A+A)' = A'.</li>
                                            <li><strong>OR from NOR:</strong> A NOR gate followed by a NOR gate configured as a NOT gate. (A+B)'' = A+B.</li>
                                            <li><strong>AND from NOR:</strong> Using De Morgan's theorem, A⋅B = (A'+B')'. This involves inverting each input using NOR gates (configured as NOTs) and then NORing the results.</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                        </ol>
                        <p><strong>Significance of Universal Gates:</strong></p>
                        <ul>
                            <li><strong>Reduced IC Count:</strong> Since any logic function can be built using only one type of universal gate, it can simplify the design and reduce the number of different types of ICs needed in a circuit.</li>
                            <li><strong>Manufacturing Efficiency:</strong> It's often more economical to manufacture and stock large quantities of a single type of universal gate IC.</li>
                            <li><strong>Design Flexibility:</strong> They provide a standard building block from which all other digital logic operations can be derived.</li>
                        </ul>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>9. Define Fan-in and Fan-out.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~2, Example Papers: W2024, S2023)</p>
                    <div class="answer-section">
                        <p>Fan-in and Fan-out are important parameters that characterize the input and output capabilities of digital logic gates, respectively. They are crucial considerations in digital circuit design for ensuring proper operation and interfacing between gates.</p>
                        
                        <p><strong>Fan-in:</strong></p>
                        <ul>
                            <li><strong>Definition:</strong> Fan-in of a logic gate is defined as the **maximum number of inputs that the gate is designed to accept and process correctly**.</li>
                            <li>For example, a standard 2-input AND gate has a fan-in of 2. A 4-input NAND gate has a fan-in of 4.</li>
                            <li><strong>Significance:</strong>
                                <ul>
                                    <li>It determines the complexity of the Boolean function that can be directly implemented by a single gate. A gate with a higher fan-in can combine more input variables in a single logic operation (e.g., an 8-input AND gate).</li>
                                    <li>Increasing the fan-in of a gate typically increases its internal complexity (e.g., more transistors or diodes in the input stage). This can, in turn, lead to increased propagation delay through the gate and potentially higher power consumption.</li>
                                    <li>Logic gate ICs are commonly available with standard fan-in values (e.g., 2, 3, 4, or 8 inputs). If a logic function requires more inputs than available on a single gate, multiple gates must be cascaded or combined.</li>
                                </ul>
                            </li>
                        </ul>
                        <hr class="section-divider"/>
                        <p><strong>Fan-out:</strong></p>
                        <ul>
                            <li><strong>Definition:</strong> Fan-out of a logic gate is defined as the **maximum number of standard inputs of gates from the *same logic family* that the output of the gate can reliably drive** without its output voltage levels degrading beyond the specified logic HIGH (V<sub>OH(min)</sub>) and logic LOW (V<sub>OL(max)</sub>) limits, or without exceeding its output current sourcing/sinking capabilities.</li>
                            <li>It essentially represents the current driving capability of a gate's output stage.</li>
                            <li><strong>Calculation (DC Fan-out):</strong> Fan-out is often determined by current parameters:
                                <ul>
                                    <li>High-level fan-out (N<sub>H</sub>) = I<sub>OH(max)</sub> / I<sub>IH(max)</sub> (Maximum output current when HIGH / Maximum input current required by a load when HIGH)</li>
                                    <li>Low-level fan-out (N<sub>L</sub>) = I<sub>OL(max)</sub> / I<sub>IL(max)</sub> (Maximum output current when LOW / Maximum input current sunk by a load when LOW)</li>
                                    <li>The overall DC fan-out of the gate is the minimum of N<sub>H</sub> and N<sub>L</sub>.</li>
                                </ul>
                            </li>
                            <li><strong>Significance:</strong>
                                <ul>
                                    <li>It is a critical parameter for ensuring reliable circuit operation. If a gate's output is connected to more inputs than its specified fan-out (i.e., it is overloaded), the output voltage levels may not be maintained within the defined logic ranges. This can lead to incorrect logic interpretation by the driven gates and malfunction of the circuit.</li>
                                    <li>Exceeding the fan-out can also lead to increased propagation delays of the driving gate and, in severe cases, could potentially damage the driving gate due to excessive current draw.</li>
                                    <li>For CMOS logic gates driving other CMOS gates, the DC fan-out is typically very high because the input impedance of CMOS gates is extremely high (drawing negligible DC current). In such cases, AC fan-out, which is limited by the capacitive load of the driven gates and its effect on switching speed, becomes a more critical consideration.</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>10. Convert a given binary number to its decimal equivalent.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~3, Example Papers: S2024, W2023, W2022)</p>
                    <div class="answer-section">
                        <p>To convert a binary number (base-2) to its decimal equivalent (base-10), each digit of the binary number is multiplied by 2 raised to the power of its position, and the results are summed up. The position is determined relative to the binary point (radix point).</p>
                        <ul>
                            <li>For the integer part (to the left of the binary point), the rightmost bit has a position of 0, the next bit to its left has a position of 1, and so on, increasing to the left.</li>
                            <li>For the fractional part (to the right of the binary point), the first bit to the right has a position of -1, the next bit to its right has a position of -2, and so on, decreasing to the right.</li>
                        </ul>
                        <p><strong>Formula:</strong></p>
                        <p>If a binary number is represented as (b<sub>n</sub>b<sub>n-1</sub>...b<sub>1</sub>b<sub>0</sub> . b<sub>-1</sub>b<sub>-2</sub>...b<sub>-m</sub>)<sub>2</sub>, its decimal equivalent is:</p>
                        <p>Decimal Value = (b<sub>n</sub> × 2<sup>n</sup>) + (b<sub>n-1</sub> × 2<sup>n-1</sup>) + ... + (b<sub>1</sub> × 2<sup>1</sup>) + (b<sub>0</sub> × 2<sup>0</sup>) + (b<sub>-1</sub> × 2<sup>-1</sup>) + (b<sub>-2</sub> × 2<sup>-2</sup>) + ... + (b<sub>-m</sub> × 2<sup>-m</sup>)</p>
                        
                        <p><strong>Example 1: Convert binary integer (11010)<sub>2</sub> to decimal.</strong></p>
                        <p>The binary number is 11010.</p>
                        <ul>
                            <li>Bit b<sub>4</sub> (MSB) = 1, position = 4 (Weight = 2<sup>4</sup> = 16)</li>
                            <li>Bit b<sub>3</sub> = 1, position = 3 (Weight = 2<sup>3</sup> = 8)</li>
                            <li>Bit b<sub>2</sub> = 0, position = 2 (Weight = 2<sup>2</sup> = 4)</li>
                            <li>Bit b<sub>1</sub> = 1, position = 1 (Weight = 2<sup>1</sup> = 2)</li>
                            <li>Bit b<sub>0</sub> (LSB) = 0, position = 0 (Weight = 2<sup>0</sup> = 1)</li>
                        </ul>
                        <p>Decimal Value = (1 × 2<sup>4</sup>) + (1 × 2<sup>3</sup>) + (0 × 2<sup>2</sup>) + (1 × 2<sup>1</sup>) + (0 × 2<sup>0</sup>)</p>
                        <p>= (1 × 16) + (1 × 8) + (0 × 4) + (1 × 2) + (0 × 1)</p>
                        <p>= 16 + 8 + 0 + 2 + 0</p>
                        <p>= <strong>26</strong></p>
                        <p>So, (11010)<sub>2</sub> = (26)<sub>10</sub>.</p>

                        <p><strong>Example 2: Convert binary number with fraction (1011.011)<sub>2</sub> to decimal.</strong></p>
                        <p><strong>Integer part:</strong> 1011</p>
                        <ul>
                            <li>1 × 2<sup>3</sup> = 1 × 8 = 8</li>
                            <li>0 × 2<sup>2</sup> = 0 × 4 = 0</li>
                            <li>1 × 2<sup>1</sup> = 1 × 2 = 2</li>
                            <li>1 × 2<sup>0</sup> = 1 × 1 = 1</li>
                        </ul>
                        <p>Integer Decimal Value = 8 + 0 + 2 + 1 = 11.</p>
                        <p><strong>Fractional part:</strong> .011</p>
                        <ul>
                            <li>0 × 2<sup>-1</sup> = 0 × (1/2) = 0 × 0.5 = 0</li>
                            <li>1 × 2<sup>-2</sup> = 1 × (1/4) = 1 × 0.25 = 0.25</li>
                            <li>1 × 2<sup>-3</sup> = 1 × (1/8) = 1 × 0.125 = 0.125</li>
                        </ul>
                        <p>Fractional Decimal Value = 0 + 0.25 + 0.125 = 0.375.</p>
                        <p>Combining the integer and fractional parts:</p>
                        <p>Total Decimal Value = 11 + 0.375 = <strong>11.375</strong></p>
                        <p>So, (1011.011)<sub>2</sub> = (11.375)<sub>10</sub>.</p>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>11. What is a multiplexer (MUX)?</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~2, Example Papers: S2023, W2021)</p>
                    <div class="answer-section">
                        <p>A **Multiplexer (MUX)**, often abbreviated as MUX and also known as a **data selector**, is a combinational logic circuit that selects one of several analog or digital input signals and forwards the selected input to a single output line. The selection of a particular input line to be routed to the output is controlled by a set of **select lines** (or control inputs).</p>
                        <p><strong>Key Characteristics and Operation:</strong></p>
                        <ul>
                            <li><strong>Function:</strong> It essentially acts like a digitally controlled multi-position switch. It routes one of its many input lines to a single output line.</li>
                            <li><strong>Inputs:</strong>
                                <ul>
                                    <li><strong>Data Inputs (I<sub>0</sub>, I<sub>1</sub>, ..., I<sub>m-1</sub>):</strong> It has 'm' data input lines. The number of data inputs is typically a power of 2, i.e., m = 2<sup>n</sup>.</li>
                                    <li><strong>Select Lines (S<sub>0</sub>, S<sub>1</sub>, ..., S<sub>n-1</sub>):</strong> It has 'n' select lines. The binary code applied to these select lines determines which one of the 2<sup>n</sup> data input lines is connected to the output.</li>
                                    <li><strong>Enable Input (E or G) (Optional):</strong> Many multiplexers also include an enable input (often active-low, E'). When the enable input is active, the MUX performs its selection function. When disabled, the output might be held at a specific logic level (e.g., LOW) or go into a high-impedance state (if it's a tri-state output MUX).</li>
                                </ul>
                            </li>
                            <li><strong>Output:</strong> It has a single output line (Y), which carries the data from the data input line selected by the select lines.</li>
                            <li><strong>Relationship between Data Inputs and Select Lines:</strong> If there are 'n' select lines, the multiplexer can select from 2<sup>n</sup> data input lines.
                                <ul>
                                    <li>A 2:1 MUX has 2 data inputs and 1 select line (2<sup>1</sup>=2).</li>
                                    <li>A 4:1 MUX has 4 data inputs and 2 select lines (2<sup>2</sup>=4).</li>
                                    <li>An 8:1 MUX has 8 data inputs and 3 select lines (2<sup>3</sup>=8).</li>
                                    <li>And so on (e.g., 16:1 MUX has 4 select lines).</li>
                                </ul>
                            </li>
                        </ul>
                        <p><strong>Working Principle (Example: 4:1 MUX):</strong></p>
                        <p>A 4:1 MUX has four data inputs (I<sub>0</sub>, I<sub>1</sub>, I<sub>2</sub>, I<sub>3</sub>) and two select lines (S<sub>1</sub>, S<sub>0</sub>). The output Y is determined as follows:</p>
                        <table>
                            <thead>
                                <tr><th>S<sub>1</sub></th><th>S<sub>0</sub></th><th>Selected Input</th><th>Output Y</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>0</td><td>0</td><td>I<sub>0</sub></td><td>Y = I<sub>0</sub></td></tr>
                                <tr><td>0</td><td>1</td><td>I<sub>1</sub></td><td>Y = I<sub>1</sub></td></tr>
                                <tr><td>1</td><td>0</td><td>I<sub>2</sub></td><td>Y = I<sub>2</sub></td></tr>
                                <tr><td>1</td><td>1</td><td>I<sub>3</sub></td><td>Y = I<sub>3</sub></td></tr>
                            </tbody>
                        </table>
                        <p>The Boolean expression for a 4:1 MUX is: Y = S<sub>1</sub>'S<sub>0</sub>'I<sub>0</sub> + S<sub>1</sub>'S<sub>0</sub>I<sub>1</sub> + S<sub>1</sub>S<sub>0</sub>'I<sub>2</sub> + S<sub>1</sub>S<sub>0</sub>I<sub>3</sub></p>
                        <div class="diagram-description">
                            <p><strong>Block Diagram of a 4:1 MUX:</strong></p>
                            <p>A rectangular block labeled "MUX 4:1".
                            <ul>
                                <li>Four data input lines on one side (I<sub>0</sub>, I<sub>1</sub>, I<sub>2</sub>, I<sub>3</sub>).</li>
                                <li>Two select lines on another side (S<sub>1</sub>, S<sub>0</sub>).</li>
                                <li>One output line on the opposite side (Y).</li>
                                <li>(Optionally, an Enable input E).</li>
                            </ul>
                            </p>
                            <img src="images/3_mark/Q11.png" alt="Block Diagram of a 4:1 Multiplexer">
                        </div>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>12. List applications of counters.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~1, Example Papers: S2022)</p>
                    <div class="answer-section">
                        <p>Counters are fundamental sequential logic circuits that go through a predetermined sequence of states upon the application of input pulses (typically clock pulses). They have a wide range of applications in digital systems and electronics. Some key applications include:</p>
                        <ol>
                            <li>
                                <strong>Frequency Division:</strong>
                                <ul>
                                    <li>Counters can be used to divide the frequency of a clock signal. A MOD-N counter (a counter that cycles through N states) will produce an output pulse at its most significant bit (or a specific decoded state) for every N input clock pulses. Thus, the output frequency is f<sub>in</sub> / N.</li>
                                    <li>Example: A MOD-10 (decade) counter can divide a 1 kHz clock signal to produce a 100 Hz signal.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Timing and Sequencing:</strong>
                                <ul>
                                    <li>Counters are essential for generating timing signals and controlling the sequence of operations in digital systems. Different states of the counter can be decoded to trigger specific events at precise time intervals.</li>
                                    <li>Example: In a microprocessor, instruction cycles are often timed and sequenced using counters.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Event Counting:</strong>
                                <ul>
                                    <li>As their name suggests, counters can be used to count the number of occurrences of an event or pulses. The event to be counted provides the clock input to the counter.</li>
                                    <li>Example: Counting items on a conveyor belt, counting revolutions of a shaft, or counting button presses.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Digital Clocks and Timers:</strong>
                                <ul>
                                    <li>Counters form the core of digital clocks and timers. They count pulses from a stable frequency source (like a crystal oscillator) and are decoded to display seconds, minutes, and hours.</li>
                                    <li>Example: Wristwatches, stopwatches, microwave oven timers.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Analog-to-Digital Converters (ADCs):</strong>
                                <ul>
                                    <li>Certain types of ADCs, such as counter-type ADCs and tracking ADCs, use counters as part of their conversion process. The counter's output is fed to a DAC, and the DAC's output is compared with the analog input.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Frequency Measurement:</strong>
                                <ul>
                                    <li>By counting the number of pulses of an unknown frequency signal within a precisely defined time interval (gate time), the frequency of the signal can be determined.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Address Generation in Memory Systems:</strong>
                                <ul>
                                    <li>Counters can be used to generate sequential memory addresses for reading or writing data in blocks.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Waveform Generation:</strong>
                                <ul>
                                    <li>The outputs of different stages of a counter can be combined using logic gates to generate various waveforms and pulse sequences.</li>
                                    <li>Example: Generating square waves with different duty cycles or specific pulse patterns.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>State Machines:</strong>
                                <ul>
                                    <li>Counters can form part of the state register in finite state machines (FSMs) when the states follow a sequential pattern.</li>
                                </ul>
                            </li>
                        </ol>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>13. What is Gray code? Give an example.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~2, Example Papers: W2024, S2023)</p>
                    <div class="answer-section">
                        <p><strong>Gray Code:</strong></p>
                        <p>Gray code, also known as Reflected Binary Code (RBC) after its inventor Frank Gray, is a binary numeral system where two successive values differ in only one bit (binary digit). This property is also called the "minimum change" or "unit distance" property.</p>
                        <p>Unlike standard binary code (natural binary code), where multiple bits can change when incrementing from one value to the next (e.g., from 0111 (7) to 1000 (8) all four bits change), Gray code ensures that only a single bit flip occurs between consecutive code words.</p>
                        
                        <p><strong>Key Characteristics:</strong></p>
                        <ul>
                            <li><strong>Unit Distance:</strong> Only one bit changes between any two successive code words in the sequence.</li>
                            <li><strong>Non-Weighted Code:</strong> Gray code is not a weighted code, meaning the bit positions do not have fixed weights (like 8, 4, 2, 1 in BCD or standard binary). Therefore, arithmetic operations like addition and subtraction cannot be performed directly on Gray coded numbers in the same way as with weighted binary codes.</li>
                            <li><strong>Reflected Property:</strong> An n-bit Gray code sequence can be generated by reflecting the (n-1)-bit sequence. For example, a 2-bit Gray code (00, 01, 11, 10) can be seen as the 1-bit sequence (0, 1) prefixed with 0 (00, 01), followed by the reflected 1-bit sequence (1, 0) prefixed with 1 (11, 10).</li>
                            <li><strong>Cyclic:</strong> The Gray code is cyclic, meaning that after the last code word in a sequence, the next code word (if the sequence were to wrap around) would also differ by only one bit from the first code word.</li>
                        </ul>

                        <p><strong>Example of a 4-bit Gray Code Sequence (compared to Binary):</strong></p>
                        <table>
                            <thead>
                                <tr><th>Decimal</th><th>Binary Code</th><th>Gray Code</th><th>Bits Changed from Previous Gray Code</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>0</td><td>0000</td><td>0000</td><td>-</td></tr>
                                <tr><td>1</td><td>0001</td><td>0001</td><td>1 (LSB)</td></tr>
                                <tr><td>2</td><td>0010</td><td>0011</td><td>1 (Bit 1)</td></tr>
                                <tr><td>3</td><td>0011</td><td>0010</td><td>1 (LSB)</td></tr>
                                <tr><td>4</td><td>0100</td><td>0110</td><td>1 (Bit 2)</td></tr>
                                <tr><td>5</td><td>0101</td><td>0111</td><td>1 (LSB)</td></tr>
                                <tr><td>6</td><td>0110</td><td>0101</td><td>1 (Bit 1)</td></tr>
                                <tr><td>7</td><td>0111</td><td>0100</td><td>1 (LSB)</td></tr>
                                <tr><td>8</td><td>1000</td><td>1100</td><td>1 (MSB)</td></tr>
                                <tr><td>9</td><td>1001</td><td>1101</td><td>1 (LSB)</td></tr>
                                </tbody>
                        </table>

                        <p><strong>Conversion Example (Binary to Gray):</strong></p>
                        <p>To convert an n-bit binary number B = B<sub>n-1</sub>B<sub>n-2</sub>...B<sub>1</sub>B<sub>0</sub> to an n-bit Gray code G = G<sub>n-1</sub>G<sub>n-2</sub>...G<sub>1</sub>G<sub>0</sub>:</p>
                        <ul>
                            <li>G<sub>n-1</sub> = B<sub>n-1</sub> (MSB is the same)</li>
                            <li>G<sub>i</sub> = B<sub>i+1</sub> ⊕ B<sub>i</sub> for i from n-2 down to 0 (where ⊕ is the XOR operation).</li>
                        </ul>
                        <p>Example: Convert binary 1011 to Gray code.</p>
                        <ul>
                            <li>B<sub>3</sub>=1, B<sub>2</sub>=0, B<sub>1</sub>=1, B<sub>0</sub>=1</li>
                            <li>G<sub>3</sub> = B<sub>3</sub> = 1</li>
                            <li>G<sub>2</sub> = B<sub>3</sub> ⊕ B<sub>2</sub> = 1 ⊕ 0 = 1</li>
                            <li>G<sub>1</sub> = B<sub>2</sub> ⊕ B<sub>1</sub> = 0 ⊕ 1 = 1</li>
                            <li>G<sub>0</sub> = B<sub>1</sub> ⊕ B<sub>0</sub> = 1 ⊕ 1 = 0</li>
                        </ul>
                        <p>So, binary (1011)<sub>2</sub> is (1110)<sub>Gray</sub>.</p>

                        <p><strong>Applications:</strong></p>
                        <ul>
                            <li><strong>Position Encoders:</strong> Used in rotary and linear encoders to represent angular or linear position. The unit distance property prevents large erroneous readings if the sensor is between two positions, as only one bit changes.</li>
                            <li><strong>Error Minimization in Digital Systems:</strong> Reduces the chance of errors when transitioning between states, as only one bit changes.</li>
                            <li><strong>Karnaugh Maps (K-maps):</strong> The ordering of rows and columns in K-maps uses Gray code to ensure adjacent cells differ by only one variable.</li>
                            <li><strong>Digital Communications:</strong> Can be used to reduce errors caused by transient states during data transmission.</li>
                        </ul>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>14. Draw the logic symbol and truth table for an AND gate.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~1, Example Papers: W2022)</p>
                    <div class="answer-section">
                        <p>An **AND gate** is a basic digital logic gate that implements logical conjunction – it returns a HIGH output (logic 1) only if all of its inputs are HIGH (logic 1). If any of its inputs are LOW (logic 0), the output will be LOW (logic 0).</p>
                        
                        <p><strong>Logic Symbol:</strong></p>
                        <p>The standard logic symbol for an AND gate depends on the number of inputs. For a 2-input AND gate:</p>
                        <div class="diagram-description">
                            <p>The symbol is typically D-shaped.
                            <ul>
                                <li>The flat side has the input lines (e.g., A and B).</li>
                                <li>The curved side has the single output line (e.g., Y).</li>
                            </ul>
                            </p>
                            <img src="images/3_mark/Q14.png" alt="Logic Symbol of a 2-Input AND Gate">
                        </div>
                        <p>For a 3-input AND gate, there would be three input lines on the flat side.</p>

                        <p><strong>Truth Table (for a 2-input AND gate):</strong></p>
                        <p>The truth table defines the output Y for all possible combinations of inputs A and B.</p>
                        <table>
                            <thead>
                                <tr><th>Input A</th><th>Input B</th><th>Output Y (A ⋅ B)</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>0</td><td>0</td><td>0</td></tr>
                                <tr><td>0</td><td>1</td><td>0</td></tr>
                                <tr><td>1</td><td>0</td><td>0</td></tr>
                                <tr><td>1</td><td>1</td><td>1</td></tr>
                            </tbody>
                        </table>

                        <p><strong>Boolean Expression:</strong></p>
                        <p>The logical operation of an AND gate is represented by the dot (⋅) symbol or sometimes by no symbol between variables (like multiplication).</p>
                        <p>For a 2-input AND gate: <strong>Y = A ⋅ B</strong>  (or Y = AB)</p>
                        <p>For a 3-input AND gate with inputs A, B, C: Y = A ⋅ B ⋅ C (or Y = ABC)</p>
                        
                        <p><strong>Explanation:</strong></p>
                        <p>The AND gate is fundamental in digital logic. It is used in various applications such as:
                        <ul>
                            <li><strong>Control Logic:</strong> Enabling or disabling a signal path. If one input is a control signal, the output will follow the other input only when the control signal is HIGH.</li>
                            <li><strong>Implementing Boolean Functions:</strong> As a building block for more complex logic circuits and arithmetic units.</li>
                            <li><strong>Address Decoding:</strong> In memory systems to select a specific memory location.</li>
                        </ul>
                        </p>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>15. Define propagation delay in logic gates.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~2, Example Papers: S2024, W2021)</p>
                    <div class="answer-section">
                        <p><strong>Propagation Delay (t<sub>p</sub>) in Logic Gates:</strong></p>
                        <p>Propagation delay is a fundamental performance characteristic of digital logic gates and integrated circuits (ICs). It quantifies the time it takes for a change in an input signal to produce a corresponding change in the output signal of the gate.</p>
                        <p><strong>Definition:</strong></p>
                        <p>More precisely, propagation delay is typically measured as the time interval between the point when the input signal crosses a specific voltage threshold (usually 50% of its total logic swing) and the point when the output signal crosses its corresponding 50% voltage threshold.</p>
                        <p>Due to differences in internal transistor switching characteristics for rising and falling edges, two distinct propagation delays are often specified:</p>
                        <ul>
                            <li><strong>t<sub>pLH</sub> (Propagation Delay, Low-to-High):</strong> The time taken for the output to transition from a LOW logic level to a HIGH logic level after the input has caused this change.</li>
                            <li><strong>t<sub>pHL</sub> (Propagation Delay, High-to-Low):</strong> The time taken for the output to transition from a HIGH logic level to a LOW logic level after the input has caused this change.</li>
                        </ul>
                        <p>The overall or average propagation delay for a gate is often calculated as:</p>
                        <p><strong>t<sub>p</sub> = (t<sub>pLH</sub> + t<sub>pHL</sub>) / 2</strong></p>
                        
                        <p><strong>Significance:</strong></p>
                        <ul>
                            <li><strong>Operating Speed:</strong> Propagation delay is a primary factor limiting the maximum operating speed or clock frequency of a digital circuit. Gates with lower propagation delays can switch faster, allowing for higher clock rates and faster overall system performance.</li>
                            <li><strong>Timing Analysis:</strong> It is a critical parameter in timing analysis of digital circuits, especially for sequential circuits, to ensure that signals arrive at the correct times and to avoid race conditions or setup/hold time violations in flip-flops.</li>
                            <li><strong>Cumulative Effect:</strong> In a path with multiple gates, the total propagation delay is roughly the sum of the propagation delays of the individual gates in that path.</li>
                        </ul>
                        <p><strong>Factors Affecting Propagation Delay:</strong></p>
                        <ul>
                            <li><strong>Logic Family Technology:</strong> Different logic families (e.g., TTL, CMOS, ECL) have inherently different propagation delays due to their transistor types and circuit structures. ECL is generally the fastest, while older CMOS can be slower.</li>
                            <li><strong>Supply Voltage:</strong> For CMOS, propagation delay typically decreases with increasing supply voltage (up to a certain point).</li>
                            <li><strong>Temperature:</strong> Propagation delay usually increases with increasing temperature.</li>
                            <li><strong>Load Capacitance:</strong> The amount of capacitance connected to the output of a gate (from driven gates and wiring) significantly affects its propagation delay. Higher load capacitance increases the time needed to charge or discharge that capacitance, thus increasing t<sub>pLH</sub> and t<sub>pHL</sub>.</li>
                            <li><strong>Internal Gate Complexity (Fan-in):</strong> Gates with higher fan-in or more complex internal logic may have longer propagation delays.</li>
                        </ul>
                        <p><strong>Unit:</strong> Propagation delay is typically measured in nanoseconds (ns) or picoseconds (ps).</p>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>16. What is a decoder?</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~1, Example Papers: S2023)</p>
                    <div class="answer-section">
                        <p>A **Decoder** is a combinational logic circuit that converts a binary input code (typically 'n' bits) into a set of output signals, where only one of the output lines (or a specific combination) is activated for each unique input code. Essentially, it "decodes" the binary input into a more recognizable or usable format.</p>
                        <p><strong>Key Characteristics:</strong></p>
                        <ul>
                            <li><strong>Inputs:</strong> It has 'n' input lines.</li>
                            <li><strong>Outputs:</strong> It has up to 2<sup>n</sup> output lines. Each output line corresponds to one of the 2<sup>n</sup> possible binary input combinations.</li>
                            <li><strong>Operation:</strong> For any given n-bit input code, only one specific output line is asserted (e.g., goes HIGH, or goes LOW if it's an active-low output decoder), while all other output lines remain de-asserted.</li>
                            <li><strong>Enable Input(s) (Optional):</strong> Many decoders also include one or more enable inputs (E or G). When the enable input is active, the decoder functions normally. When disabled, all outputs are typically forced to an inactive state (e.g., all LOW or all HIGH, or sometimes into a high-impedance state if they are tri-state outputs).</li>
                        </ul>
                        <p><strong>Common Types:</strong></p>
                        <ul>
                            <li><strong>n-to-2<sup>n</sup> Line Decoder:</strong> The most common type. For example:
                                <ul>
                                    <li><strong>2-to-4 Line Decoder:</strong> Has 2 input lines (A<sub>1</sub>, A<sub>0</sub>) and 4 output lines (Y<sub>0</sub>, Y<sub>1</sub>, Y<sub>2</sub>, Y<sub>3</sub>). If A<sub>1</sub>A<sub>0</sub> = 00, Y<sub>0</sub> is active; if A<sub>1</sub>A<sub>0</sub> = 01, Y<sub>1</sub> is active, and so on.</li>
                                    <li><strong>3-to-8 Line Decoder:</strong> Has 3 input lines and 8 output lines.</li>
                                    <li><strong>4-to-16 Line Decoder:</strong> Has 4 input lines and 16 output lines.</li>
                                </ul>
                            </li>
                            <li><strong>BCD-to-Decimal Decoder (or 4-to-10 Line Decoder):</strong> Specifically designed to decode a 4-bit BCD (Binary Coded Decimal) input (representing decimal digits 0-9) and activate one of ten output lines corresponding to the decimal digit.</li>
                            <li><strong>BCD-to-7-Segment Decoder:</strong> Converts a 4-bit BCD input into the 7 output signals required to drive a 7-segment display, illuminating the appropriate segments to display the decimal digit.</li>
                        </ul>
                        <div class="diagram-description">
                            <p><strong>Block Diagram of a 2-to-4 Line Decoder:</strong></p>
                            <p>A rectangular block labeled "Decoder 2x4".
                            <ul>
                                <li>Two input lines on one side (A<sub>1</sub>, A<sub>0</sub>).</li>
                                <li>(Optionally, an Enable input E).</li>
                                <li>Four output lines on the opposite side (Y<sub>0</sub>, Y<sub>1</sub>, Y<sub>2</sub>, Y<sub>3</sub>).</li>
                            </ul>
                            </p>
                            <img src="images/3_mark/Q16.ppm" alt="Block Diagram of a 2-to-4 Line Decoder">
                        </div>
                        <p><strong>Applications:</strong></p>
                        <ul>
                            <li><strong>Address Decoding:</strong> In memory systems to select a specific memory chip or location based on an address from the CPU.</li>
                            <li><strong>Data Demultiplexing:</strong> A decoder with an enable input can function as a demultiplexer, routing a single data input to one of several output lines based on the select inputs.</li>
                            <li><strong>Instruction Decoding:</strong> In CPUs to interpret instruction opcodes.</li>
                            <li><strong>Controlling Output Devices:</strong> Activating one specific device or display segment among many.</li>
                        </ul>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>17. List types of shift registers.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~2, Example Papers: W2024, S2022)</p>
                    <div class="answer-section">
                        <p>A **shift register** is a sequential logic circuit composed of a cascade of flip-flops, sharing a common clock, in which the binary information stored in the flip-flops can be shifted from one flip-flop to the next with each clock pulse. Shift registers are primarily classified based on how data is loaded into them (serial or parallel) and how data is retrieved from them (serial or parallel).</p>
                        <p>The main types of shift registers are:</p>
                        <ol>
                            <li>
                                <p><strong>SISO (Serial-In, Serial-Out):</strong></p>
                                <ul>
                                    <li><strong>Data Input:</strong> Data is loaded into the register one bit at a time (serially) through a single input line, typically at one end of the register.</li>
                                    <li><strong>Data Output:</strong> Data is retrieved from the register one bit at a time (serially) from a single output line, typically at the other end of the register.</li>
                                    <li><strong>Operation:</strong> With each clock pulse, the data bits shift one position along the chain of flip-flops. An N-bit SISO register requires N clock pulses to load an N-bit word and another N pulses (or N pulses from the start of loading the first bit) to shift the entire word out.</li>
                                    <li><strong>Application:</strong> Serial data transmission, time delays.</li>
                                </ul>
                            </li>
                            <li>
                                <p><strong>SIPO (Serial-In, Parallel-Out):</strong></p>
                                <ul>
                                    <li><strong>Data Input:</strong> Data is loaded serially, one bit at a time.</li>
                                    <li><strong>Data Output:</strong> All stored bits are available simultaneously on parallel output lines (one output line per flip-flop).</li>
                                    <li><strong>Operation:</strong> Data shifts serially into the register. Once the desired number of bits is loaded (after N clock pulses for an N-bit word), all N bits can be read out in parallel at the same time.</li>
                                    <li><strong>Application:</strong> Converting serial data to parallel data (e.g., in serial communication receivers).</li>
                                </ul>
                            </li>
                            <li>
                                <p><strong>PISO (Parallel-In, Serial-Out):</strong></p>
                                <ul>
                                    <li><strong>Data Input:</strong> All bits of a data word are loaded into the register simultaneously (in parallel) via multiple input lines, typically using a "load" control signal.</li>
                                    <li><strong>Data Output:</strong> Data is retrieved from the register one bit at a time (serially) from a single output line (usually from the last flip-flop).</li>
                                    <li><strong>Operation:</strong> An N-bit word is loaded in one clock cycle (with the load signal active). Then, N clock pulses are required to shift all the bits out serially.</li>
                                    <li><strong>Application:</strong> Converting parallel data to serial data (e.g., in serial communication transmitters).</li>
                                </ul>
                            </li>
                            <li>
                                <p><strong>PIPO (Parallel-In, Parallel-Out):</strong></p>
                                <ul>
                                    <li><strong>Data Input:</strong> All bits are loaded simultaneously (in parallel).</li>
                                    <li><strong>Data Output:</strong> All stored bits are available simultaneously on parallel output lines.</li>
                                    <li><strong>Operation:</strong> This type of register is primarily used for temporary data storage or as a buffer. Data is loaded in one clock cycle and can be read out in one clock cycle. It doesn't inherently perform shifting unless combined with other control logic.</li>
                                    <li><strong>Application:</strong> Data buffering, temporary storage registers.</li>
                                </ul>
                            </li>
                            <li>
                                <p><strong>Universal Shift Register:</strong></p>
                                <ul>
                                    <li><strong>Operation:</strong> This is a more versatile type that can perform multiple operations, such as serial shift left, serial shift right, parallel load, and hold (no change), selected by mode control inputs.</li>
                                    <li><strong>Application:</strong> General-purpose data manipulation, arithmetic operations (like multiplication/division by powers of 2 through shifting).</li>
                                </ul>
                            </li>
                            <li>
                                <p><strong>Bidirectional Shift Register:</strong></p>
                                <ul>
                                    <li><strong>Operation:</strong> Can shift data in both directions (left-to-right or right-to-left), controlled by a direction control input.</li>
                                    <li><strong>Application:</strong> Arithmetic operations, data manipulation requiring bidirectional movement.</li>
                                </ul>
                            </li>
                        </ol>
                        <p>Shift registers are fundamental components in digital systems for data storage, data movement, data conversion (serial-to-parallel and parallel-to-serial), and in constructing counters like ring counters and Johnson counters.</p>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>18. What is meant by 'volatile memory'?</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~1, Example Papers: W2023)</p>
                    <div class="answer-section">
                        <p><strong>Volatile Memory:</strong></p>
                        <p>In the context of computer storage and digital electronics, **volatile memory** is a type of computer memory that requires continuous electrical power to maintain the stored information. If the power supply is interrupted or turned off, the data stored in volatile memory is lost.</p>
                        <p><strong>Key Characteristics:</strong></p>
                        <ul>
                            <li><strong>Power Dependency:</strong> Its defining characteristic is that it needs constant power to retain data. When power is cut, the contents are erased.</li>
                            <li><strong>Speed:</strong> Volatile memories are generally very fast in terms of read and write access times compared to non-volatile memory types. This makes them suitable for use as the main working memory for a computer system.</li>
                            <li><strong>Primary Use:</strong> Typically used for temporary storage of data and program instructions that the CPU is actively working with. This includes the operating system, running applications, and user data currently being processed.</li>
                        </ul>
                        <p><strong>Common Examples of Volatile Memory:</strong></p>
                        <ul>
                            <li>
                                <strong>RAM (Random Access Memory):</strong> This is the most common type of volatile memory.
                                <ul>
                                    <li><strong>SRAM (Static RAM):</strong> Uses flip-flops to store each bit. It's faster and consumes more power (statically) than DRAM but doesn't need refreshing. Used for cache memory.</li>
                                    <li><strong>DRAM (Dynamic RAM):</strong> Uses a transistor and a capacitor to store each bit as a charge. The charge leaks away, so DRAM requires periodic refreshing to maintain data. It's denser and less expensive than SRAM, making it suitable for main system memory.</li>
                                </ul>
                            </li>
                            <li><strong>CPU Registers:</strong> These are extremely fast, small memory locations within the CPU itself, used for temporary storage of data and instructions being immediately processed. They are volatile.</li>
                        </ul>
                        <p><strong>Contrast with Non-Volatile Memory:</strong></p>
                        <p>Non-volatile memory, on the other hand, retains its stored information even when the power is turned off. Examples include Read-Only Memory (ROM), flash memory (used in SSDs, USB drives), hard disk drives (HDDs), and optical discs (CDs, DVDs, Blu-ray).</p>
                        <p>In summary, "volatile" signifies that the memory's contents are temporary and dependent on a continuous power supply.</p>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>19. Give the difference between combinational and sequential circuits.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~2, Example Papers: S2024, W2022)</p>
                    <div class="answer-section">
                        <p>Combinational and sequential circuits are the two fundamental categories of digital logic circuits. They differ primarily in how their outputs are determined and whether they possess memory capabilities.</p>
                        
                        <table>
                            <thead>
                                <tr><th>Feature</th><th>Combinational Circuits</th><th>Sequential Circuits</th></tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>1. Output Dependency</strong></td>
                                    <td>The output at any instant of time depends <strong>only on the present input values</strong> at that instant.</td>
                                    <td>The output at any instant of time depends not only on the <strong>present input values</strong> but also on the <strong>past history of inputs (i.e., the present state of the circuit)</strong>.</td>
                                </tr>
                                <tr>
                                    <td><strong>2. Memory Elements</strong></td>
                                    <td>Do <strong>not</strong> have memory elements. They cannot store any information about past inputs.</td>
                                    <td><strong>Contain memory elements</strong> (like flip-flops or latches) to store information about the past state of the circuit.</td>
                                </tr>
                                <tr>
                                    <td><strong>3. Feedback Path</strong></td>
                                    <td>Generally, do <strong>not</strong> have feedback paths from output back to input (except in some specific cases like latches which can be considered simple sequential circuits or complex combinational ones depending on perspective).</td>
                                    <td><strong>Typically have feedback paths</strong> from the output of memory elements to the input of the combinational logic part, which determines the next state and outputs.</td>
                                </tr>
                                <tr>
                                    <td><strong>4. Clock Input</strong></td>
                                    <td>Usually do <strong>not</strong> require a clock signal for their operation (they operate asynchronously based on input changes).</td>
                                    <td>Often (but not always, e.g., asynchronous sequential circuits) require a <strong>clock signal</strong> to synchronize state changes and operations. These are called synchronous sequential circuits.</td>
                                </tr>
                                <tr>
                                    <td><strong>5. Circuit Complexity</strong></td>
                                    <td>Generally simpler to design and analyze for a given function.</td>
                                    <td>Generally more complex to design and analyze due to the state behavior and timing considerations.</td>
                                </tr>
                                <tr>
                                    <td><strong>6. Speed of Operation</strong></td>
                                    <td>Typically faster as the output changes almost immediately (after propagation delays) with input changes.</td>
                                    <td>Operation is often governed by clock speed. State transitions occur at clock edges, which can introduce more overall delay compared to purely combinational paths.</td>
                                </tr>
                                <tr>
                                    <td><strong>7. Design Approach</strong></td>
                                    <td>Designed using truth tables, Boolean algebra, K-maps to derive logic expressions for outputs directly from inputs.</td>
                                    <td>Designed using state diagrams, state tables, excitation tables for flip-flops, K-maps for flip-flop inputs and output logic.</td>
                                </tr>
                                <tr>
                                    <td><strong>8. Examples</strong></td>
                                    <td>Adders (Half Adder, Full Adder), Subtractors, Multiplexers (MUX), Demultiplexers (DEMUX), Encoders, Decoders, Code Converters, Comparators.</td>
                                    <td>Flip-Flops (SR, JK, D, T), Latches, Counters (Ripple, Synchronous), Registers (Shift Registers, Storage Registers), Finite State Machines (FSMs), Memory units (RAM, ROM components).</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </details>

            <details class="qa-block">
                <summary>20. What is a BCD code? Represent decimal 7 in BCD.</summary>
                <div class="answer-container">
                    <p class="citation-info">(Illustrative Frequency: ~2, Example Papers: S2023, W2021)</p>
                    <div class="answer-section">
                        <p><strong>BCD (Binary Coded Decimal) Code:</strong></p>
                        <p>BCD is a system of representing decimal digits (0 through 9) using a 4-bit binary code. Instead of converting an entire decimal number into its pure binary equivalent, each decimal digit is individually converted to its 4-bit binary representation. The most common BCD scheme is the **8421 code**, where the weights of the four bits are 8, 4, 2, and 1, from the Most Significant Bit (MSB) to the Least Significant Bit (LSB).</p>
                        <p><strong>Key Characteristics:</strong></p>
                        <ul>
                            <li>Each decimal digit (0-9) is represented by a unique 4-bit binary group.</li>
                            <li>Since decimal digits only go up to 9, only 10 of the 16 possible 4-bit binary combinations (0000 to 1001) are valid BCD codes for a single digit. The combinations 1010 (binary for decimal 10) through 1111 (binary for decimal 15) are considered invalid or unused in standard 8421 BCD representation for a single digit.</li>
                            <li>BCD is useful in systems that interface with human-readable decimal displays (like digital clocks, calculators, voltmeters) because it simplifies the conversion between decimal and binary forms for display purposes.</li>
                            <li>Arithmetic operations (like addition) in BCD require special correction steps if the result of a 4-bit binary addition exceeds 9, to maintain the correct BCD representation.</li>
                        </ul>
                        <p><strong>BCD Representation Table (8421 Code):</strong></p>
                        <table>
                            <thead>
                                <tr><th>Decimal Digit</th><th>BCD Code (B<sub>3</sub>B<sub>2</sub>B<sub>1</sub>B<sub>0</sub>)</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>0</td><td>0000</td></tr>
                                <tr><td>1</td><td>0001</td></tr>
                                <tr><td>2</td><td>0010</td></tr>
                                <tr><td>3</td><td>0011</td></tr>
                                <tr><td>4</td><td>0100</td></tr>
                                <tr><td>5</td><td>0101</td></tr>
                                <tr><td>6</td><td>0110</td></tr>
                                <tr><td>7</td><td>0111</td></tr>
                                <tr><td>8</td><td>1000</td></tr>
                                <tr><td>9</td><td>1001</td></tr>
                            </tbody>
                        </table>
                        
                        <p><strong>Representing Decimal 7 in BCD:</strong></p>
                        <p>To represent the decimal digit 7 in BCD, we look up its 4-bit binary equivalent from the table above.</p>
                        <p>The BCD code for decimal 7 is <strong>0111</strong>.</p>
                        
                        <p>If we were to represent a multi-digit decimal number, each digit would be converted to its 4-bit BCD equivalent separately. For example:</p>
                        <ul>
                            <li>Decimal 27 would be represented in BCD as:
                                <ul>
                                    <li>2 → 0010</li>
                                    <li>7 → 0111</li>
                                </ul>
                                So, (27)<sub>10</sub> = (0010 0111)<sub>BCD</sub>.
                            </li>
                        </ul>
                    </div>
                </div>
            </details>

        </section>
    </div>

    <script>
        // Script to make answers collapsible
        document.addEventListener('DOMContentLoaded', () => {
            const detailsElements = document.querySelectorAll('details.qa-block');
            detailsElements.forEach(detail => {
                // Optional: If you want only one open at a time, uncomment below
                // detail.addEventListener('toggle', event => {
                //     if (detail.open) {
                //         detailsElements.forEach(otherDetail => {
                //             if (otherDetail !== detail) {
                //                 otherDetail.removeAttribute('open');
                //             }
                //         });
                //     }
                // });
            });
            console.log("3-Mark Q&A Page Loaded with collapsible answers.");
        });
    </script>
</body>
</html>
